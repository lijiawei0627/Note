# 一、从入口开始

在`web`应⽤下，我们来分析`Runtime + Compiler`构建出来的`Vue.js`，它的⼊⼝是	`src/platforms/web/entry-runtime-with-compiler.js`

## `Vue`的定义

```JavaScript
import { initMixin } from './init'
import { stateMixin } from './state'
import { renderMixin } from './render'
import { eventsMixin } from './events'
import { lifecycleMixin } from './lifecycle'
import { warn } from '../util/index'

// VUE是一个⽤Function实现的类，我们只能通过	new	Vue去实例化它。
function Vue (options) {
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)
}

// 给Vue的prototype上扩展⼀些⽅法
initMixin(Vue)
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)

export default Vue
```

> 为何`Vue`不⽤`ES6`的Class去实现呢？我们往后看这⾥有很多`xxxMixin`的函数调⽤，并把`Vue`当参数传⼊，它们的功能都是给`Vue`的`prototype`上扩展⼀些⽅法（这⾥具体 的细节会在之后的⽂章介绍，这⾥不展开），`Vue`按功能把这些扩展分散到多个模块中去实现，⽽不 是在⼀个模块⾥实现所有，这种⽅式是⽤	`Class`难以实现的。

# 二、数据驱动

`Vue.js`⼀个核⼼思想是数据驱动。所谓数据驱动，是指视图是由数据驱动⽣成的，我们对视图的修改， 不会直接操作`DOM`，⽽是通过修改数据。只关⼼数据的修改会让代码的逻辑变的⾮ 常清晰，因为DOM变成了数据的映射，我们所有的逻辑都是对数据的修改，⽽不⽤碰触DOM，这样 的代码⾮常利于维护。 

## `new Vue`发生了什么

```javascript
new Vue({
	el: '#app',
  data:{
    msg: {
      name: 'lijiawei',
      age: 20
    }
  }
})
```

可以看到`Vue`只能通过new关键字初始化，然后会调⽤`this._init`⽅法，该⽅法在`src/core/instance/init.js`中定义。通过调用`initMixin(Vue)`方法，在`Vue.prototype`上定义了`_init`方法

```javascript
// 代码有删减

export function initMixin (Vue: Class<Component>) {
  // 在Vue原型上定义_init方法
  Vue.prototype._init = function (options?: Object) {
    // vm指向Vue实例
    const vm: Component = this
    if (options && options._isComponent) {
      initInternalComponent(vm, options)
    } else {
      // 合并options
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      )
    }
    // 合并配置，初始化⽣命周期，初始化事件中⼼，初始化渲染，
    // 初始化data、props、computed、watcher等等。 
    initLifecycle(vm)
    initEvents(vm)
    initRender(vm)
    callHook(vm, 'beforeCreate')
    initInjections(vm) // resolve injections before data/props
    initState(vm)
    initProvide(vm) // resolve provide after data/props
    callHook(vm, 'created')

    // 检测到如果有el属性，则调⽤`vm.$mount`⽅法挂载`vm`，挂载的⽬标就是把模板渲染成最终的DOM
    if (vm.$options.el) {
      vm.$mount(vm.$options.el)
    }
  }
}
```

* `Vue`初始化主要就⼲了⼏件事情，合并配置，初始化⽣命周期，初始化事件中⼼，初始化渲染，初始化	`data、props、computed、watcher`等等。

* 在初始化的最后，检测到如果有el属性，则调⽤`vm.$mount`⽅法挂载`vm`，挂载的⽬标就 是把模板渲染成最终的DOM，那么接下来我们来分析`Vue`的挂载过程。

### `initData`、`getData`

```JavaScript
function initData (vm: Component) {
  // 获取到vue中定义的data
  let data = vm.$options.data
  // 判断data类型是否为函数，然后执行getData函数，获取data中的数据
  // 并将获取到的数据赋给vm._data
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {}
  // 最终获取到的data必须为对象，否则会报出警告
  if (!isPlainObject(data)) {
    data = {}
    process.env.NODE_ENV !== 'production' && warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    )
  }
  // 拿到data中的key值、props、methods等数据
  const keys = Object.keys(data)
  const props = vm.$options.props
  const methods = vm.$options.methods
  let i = keys.length
  // 对methods、props中的属性和data中的属性进行循环对比，判断是否存在相同属性
  while (i--) {
    const key = keys[i]
    if (process.env.NODE_ENV !== 'production') {
      if (methods && hasOwn(methods, key)) {
        warn(
          `Method "${key}" has already been defined as a data property.`,
          vm
        )
        // 方法“${key}”已定义为数据属性。
      }
    }
    if (props && hasOwn(props, key)) {
      process.env.NODE_ENV !== 'production' && warn(
        `The data property "${key}" is already declared as a prop. ` +
        `Use prop default value instead.`,
        vm
      )
			// 数据属性“${key}”已声明为prop。改为使用prop默认值
    } else if (!isReserved(key)) {
      // 在此处对vm._data上的key做了代理
      proxy(vm, `_data`, key)
    }
  }
  // observe data
  observe(data, true /* asRootData */)
}


export function getData (data: Function, vm: Component): any {
  // #7573 disable dep collection when invoking data getters
  pushTarget()
  try {
    // 执行Vue中的data函数，并且将结果返回
    return data.call(vm, vm)
  } catch (e) {
    handleError(e, vm, `data()`)
    return {}
  } finally {
    popTarget()
  }
}

export function proxy (target: Object, sourceKey: string, key: string) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  }
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val
  }
  // 在此处将vm上的data进行了代理，当我们访问vm[key]时，实际上访问的是vm[sourcekey][key]
  Object.defineProperty(target, key, sharedPropertyDefinition)
}
```

* 之所以给`data`属性设置为一个函数，是因为当一个组件被定义，data 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！通过提供 data 函数，每次创建一个新实例后，我们能够调用 data 函数，从而返回初始数据的一个全新副本数据对象。
* 如果在data中定义了‘message’或其他属性，则不可再在props，methods等方法中定义同名属性或方法。因为它们都会通过proxy函数代理到当前实例`vm`身上，同名属性或方法会产生冲突。
* 当我们访问data数据`this.message`时，其实访问的是`this._data.message`，但是‘_data’为私有属性，不推荐在对象外部调用，而应该通过`this.message`访问。

## `Vue`实例挂载的实现 

`Vue`中我们是通过`$mount实例方法去挂载vm的`，`$mount`⽅法在多个⽂件中都有定义，如`src/pltform/web/entry-runtime-withcompiler.js`	、`src/platform/web/runtime/index.js`	、`src/platform/weex/runtime/index.js`。因为`$mount`这个⽅法的实现是和平台、构建⽅式都相关的。重点分析带compiler版本的​`$monut`实现。

### complier版本的$mount方法

```JavaScript
// 代码有删减

// 缓存了runtime中的的$mount方法（缓存了原型上的$mount⽅法，再重新定义该⽅法）
const mount = Vue.prototype.$mount
Vue.prototype.$mount = function (
  // 可以传入字符串el或者直接传入元素
  el?: string | Element,
  hydrating?: boolean
): Component {
  // 如果el存在，就调用query方法对el进行转换，返回dom对象赋给el
  el = el && query(el)

  // 对el做了限制，Vue不能挂载在body、html这样的根节点上，否则会报错
  if (el === document.body || el === document.documentElement) {
    process.env.NODE_ENV !== 'production' && warn(
      `Do not mount Vue to <html> or <body> - mount to normal elements instead.`
    )
    return this
  }

  const options = this.$options
  // 当没有直接使用render函数时，解析模板/el并转换为呈现函数
  if (!options.render) {
    let template = options.template
    // 判断是否定义了template
    if (template) {
      if (typeof template === 'string') {
        // 当template是以"#tmp1"这样的形式存在时，
        // 通过idToTemplate方法（内部再次使用了query(el)方法）去获取template组件
        if (template.charAt(0) === '#') {
          template = idToTemplate(template)
          // 当没有找到对应的元素时，会进行报错
          if (process.env.NODE_ENV !== 'production' && !template) {
            warn(
              `Template element not found or is empty: ${options.template}`,
              this
            )
          }
        } 
      } else if (template.nodeType) { 
        // <template></template>
        // 拿到template的innerHTML
        template = template.innerHTML
      } else {
        if (process.env.NODE_ENV !== 'production') {
          warn('invalid template option:' + template, this)
        }
        return this
      }
    } else if (el) { // 当没有定义template时，通过getOuterHTML(el)去获取dom相关的字符串
      template = getOuterHTML(el) // template最终是字符串类型
    }
  }
  // 通过上面转换之后得到的template来得到render方法
  if (template) {
      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile')
      }

      const { render, staticRenderFns } = compileToFunctions(template, {
        outputSourceRange: process.env.NODE_ENV !== 'production',
        shouldDecodeNewlines,
        shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this)
      // 生成render方法,放到options上，方便后续使用
      options.render = render
      options.staticRenderFns = staticRenderFns

      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile end')
        measure(`vue ${this._name} compile`, 'compile', 'compile end')
      }
    }
  // 执行runtime中的$mount方法
  return mount.call(this, el, hydrating)
}
```

* 缓存了原型上的`$mount`⽅法，再重新定义该⽅法
* 对`e`l做了限制，`Vue`不能挂载在`body`、`html`这样的根节点上。
* 如果实例化`Vue`时给出了render选项，那么template其实是无效的，因为不会进入模板编译流程，而是直接使用render选项中提供的渲染函数。
* 如果没有定义render⽅法，则会把el或者template字符串（优先考虑template字符串）转换成render⽅法
* 在`Vue2.0`	版本中，所有`Vue`的组件的渲染最终都需要render⽅法，⽆论我们是⽤单⽂件 `.vue`⽅式开发组件，还是写了`el`或者`template`属性，最终都会转换成`render`⽅法
* 原先原型上的$mount⽅法在`src/platform/web/runtime/index.js`中定义，之所以这么设计完 全是为了复⽤，因为它是可以被`runtime only`版本的`Vue`直接使⽤的。

### 缓存的$mount方法

缓存的$mount⽅法实际上会去调⽤`mountComponent`⽅法，这个⽅法定义在`src/core/instance/lifecycle.js`⽂件中

```JavaScript
export function mountComponent (
  vm: Component,
  el: ?Element,
  hydrating?: boolean
): Component {
  vm.$el = el
  if (!vm.$options.render) {
    // 如果vm中没有render方法，就会创建一个空的VNode
    vm.$options.render = createEmptyVNode
    if (process.env.NODE_ENV !== 'production') {
      // 在之前的对el的转换中，没有得到template或者template不是以'#'开头时，就会进行报错
      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
        vm.$options.el || el) {
        warn(
          'You are using the runtime-only build of Vue where the template ' +
          'compiler is not available. Either pre-compile the templates into ' +
          'render functions, or use the compiler-included build.',
          vm
        )
      } else {
        warn(  // 未定义模板或者render函数
          'Failed to mount component: template or render function not defined.',
          vm
        )
      }
    }
  }
  // 执行beforeMount钩子函数
  callHook(vm, 'beforeMount')
  // 在外部声明updateComponent变量
  let updateComponent
  /* istanbul ignore if */
  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
    // 	定义updateComponent⽅法
    updateComponent = () => {
      const name = vm._name
      const id = vm._uid
      const startTag = `vue-perf-start:${id}`
      const endTag = `vue-perf-end:${id}`

      mark(startTag)
      const vnode = vm._render()
      mark(endTag)
      measure(`vue ${name} render`, startTag, endTag)

      mark(startTag)
      vm._update(vnode, hydrating)
      mark(endTag)
      measure(`vue ${name} patch`, startTag, endTag)
    }
  } else {
    // 	定义updateComponent⽅法
    updateComponent = () => {
      // 执行vue._render()生成虚拟dom（VNode），
      // 再将其传入vm._update，_update 的核心就是调用 vm.__patch__ 方法，渲染成真实dom
      vm._update(vm._render(), hydrating)
    }
  }
  // 实例化⼀个渲染`Watcher`
  new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate')
      }
    }
  }, true /* isRenderWatcher */)
  
  if (vm.$vnode == null) {
    vm._isMounted = true
    callHook(vm, 'mounted')
  }
  return vm
}
```

* 从上⾯的代码可以看到，`mountComponent`核⼼就是先调⽤`vm._render`⽅法先⽣成虚拟`Node`，再实例化⼀个渲染`Watcher`，在它的回调函数中会调⽤`updateComponent`⽅法，最终调⽤`vm._update`更新DOM。
* `Watcher`在这⾥起到两个作⽤，⼀个是初始化的时候会执⾏回调函数，另⼀个是当`vm`实例中的监测的数据发⽣变化的时候执⾏回调函数
* 函数最后判断为根节点的时候设置`vm._isMounted`为`true`，表⽰这个实例已经挂载了，同时执⾏`mounted`钩⼦函数。这⾥注意`vm.$vnode`表⽰`Vue`实例的⽗虚拟Node，所以它为`Null`则表⽰当前是根`Vue`的实例。 

`mountComponent`⽅法的逻辑也是⾮常清晰的，它会完成整个渲染⼯作，接下来我们要重点分析其中 的细节，也就是最核⼼的2个⽅法：`vm._render`和`vm._update`。

 ![image](https://upload-images.jianshu.io/upload_images/16269351-24d682a569624410.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 

 ![image](https://upload-images.jianshu.io/upload_images/16269351-ce873bd02e2847d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 

## `render`

`Vue`的_render⽅法是实例的⼀个私有⽅法，它⽤来把实例渲染成⼀个虚拟Node。它的定义在	`src/core/instance/render.js`⽂件中：

```JavaScript
// 代码有删减


Vue.prototype._render = function (): VNode {
    const vm: Component = this
    // 从options中拿到render函数
    // 该render方法可以通过用户去编写，也可以通过el或者template去生成
    const { render, _parentVnode } = vm.$options

    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode
    // render self
    let vnode
    try {
      currentRenderingInstance = vm
      // 通过vm.$createElement方法（内部使用了createElement方法）
      // 会生成一个vnode（虚拟dom）
      vnode = render.call(vm._renderProxy, vm.$createElement)
    } catch (e) {
      handleError(e, vm, `render`)
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if (process.env.NODE_ENV !== 'production' && vm.$options.renderError) {
        try {
          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)
        } catch (e) {
          handleError(e, vm, `renderError`)
          vnode = vm._vnode
        }
      } else {
        vnode = vm._vnode
      }
    } finally {
      currentRenderingInstance = null
    }
    // 只允许vnode数组中包含一个节点
    if (Array.isArray(vnode) && vnode.length === 1) {
      // 从vnode中取出节点，重新赋给vnode
      vnode = vnode[0]
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      // 判断此时vnode是否为一个数组
      // 当vnode为一个数组时，说明有多个根节点，会报错。提示根节点只能有一个vnode
      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {
        warn(
          'Multiple root nodes returned from render function. Render function ' +
          'should return a single root node.',
          vm
        )
      }
      // 如果render函数出错，返回空vnode
      vnode = createEmptyVNode()
    }
    // set parent
    vnode.parent = _parentVnode
    return vnode
  }
```

实际上，`vm.$createElement`⽅法定义是在执⾏`initRender`⽅法的时候（`src/core/instance/render.js`文件中）

```javascript
// 代码有大量删减

// 在初始化阶段就会执行initRender函数
export function initRender (vm: Component) {
  // 给编译生成的render函数提供的createElement方法，通过最后一个参数false或者true来区别
  vm._c = (a, b, c, d) => createElement(vm, a, b, c, d, false)
  // normalization is always applied for the public version, used in
  // user-written render functions.
  // 给手写render函数提供的createElement方法
  vm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true)

}
```



* 在平时的开发⼯作中⼿写`render`⽅法的场景⽐较少，⽽写的⽐较多的是`template`模板，在之前的		mounted⽅法的实现中，会把template或者el编译成render⽅法
* 除了`vm.$createElement`⽅法，还有⼀个`vm._c`⽅法，它是被模板编译成的render函数使⽤，⽽	`vm.$createElement`是⽤户⼿写render⽅法使⽤的，这俩个⽅法⽀持的参数相同，并且内部都调⽤了		`createElement`⽅法。 

* 手写render函数

  ```JavaScript
  render:	function	(createElement)	{		
  	return	createElement('div',	{					
      attrs:	{								
        id:	'app'						
      },		
    },	this.message) 
  } 
  ```

`vm._render`最终是通过执⾏`createElement`⽅法并返回的是`vnode`，它是⼀个虚拟Node。`Vue2.0`相⽐	`Vue1.0`最⼤的升级就是利⽤了`Virtual DOM`。因此在分析`createElement`的实现前，先了解⼀下`Virtual DOM`的概念。

## `Virtual DOM` 

`Virtual DOM`就是⽤⼀个原⽣的`JS`对象去描述⼀个`DOM`节点，所以它⽐创建⼀个`DOM`的代价要 ⼩很多。在	`Vue.js`中，`Virtual DOM`是⽤`VNode`这么⼀个`Class`去描述，它是定义在`src/core/vdom/vnode.js`中的。

```javascript
export default class VNode {
  tag: string | void;
  data: VNodeData | void;
  children: ?Array<VNode>;
  text: string | void;
  elm: Node | void;
  ns: string | void;
  context: Component | void; // rendered in this component's scope
  key: string | number | void;
  componentOptions: VNodeComponentOptions | void;
  componentInstance: Component | void; // component instance
  parent: VNode | void; // component placeholder node

  // strictly internal
  raw: boolean; // contains raw HTML? (server only)
  isStatic: boolean; // hoisted static node
  isRootInsert: boolean; // necessary for enter transition check
  isComment: boolean; // empty comment placeholder?
  isCloned: boolean; // is a cloned node?
  isOnce: boolean; // is a v-once node?
  asyncFactory: Function | void; // async component factory function
  asyncMeta: Object | void;
  isAsyncPlaceholder: boolean;
  ssrContext: Object | void;
  fnContext: Component | void; // real context vm for functional nodes
  fnOptions: ?ComponentOptions; // for SSR caching
  devtoolsMeta: ?Object; // used to store functional render context for devtools
  fnScopeId: ?string; // functional scope id support

  constructor (
    tag?: string,
    data?: VNodeData,
    children?: ?Array<VNode>,
    text?: string,
    elm?: Node,
    context?: Component,
    componentOptions?: VNodeComponentOptions,
    asyncFactory?: Function
  ) {
    this.tag = tag
    this.data = data
    this.children = children
    this.text = text
    this.elm = elm
    this.ns = undefined
    this.context = context
    this.fnContext = undefined
    this.fnOptions = undefined
    this.fnScopeId = undefined
    this.key = data && data.key
    this.componentOptions = componentOptions
    this.componentInstance = undefined
    this.parent = undefined
    this.raw = false
    this.isStatic = false
    this.isRootInsert = true
    this.isComment = false
    this.isCloned = false
    this.isOnce = false
    this.asyncFactory = asyncFactory
    this.asyncMeta = undefined
    this.isAsyncPlaceholder = false
  }

  // DEPRECATED: alias for componentInstance for backwards compat.
  /* istanbul ignore next */
  get child (): Component | void {
    return this.componentInstance
  }
}
```

* 其实`VNode`是对真实DOM的⼀种抽象描述，它的核⼼定义⽆⾮就⼏个关键属性，标签名、数据、⼦ 节点、键值等，其它属性都是都是⽤来扩展`VNode`的灵活性以及实现⼀些特殊feature的。由于`VNode` 只是⽤来映射到真实DOM的渲染，不需要包含操作DOM的⽅法，因此它是⾮常轻量和简单的。 

* `Virtual DOM`除了它的数据结构的定义，映射到真实的DOM实际上要经历`VNode`的create、`diff`、 patch等过程。那么在`Vue.js`中，`VNode`的create是通过之前提到的`createElement`⽅法创建的，patch是通过`vm._update`渲染的，我们接下来分析create部分是实现。

## `createElement`

`Vue.js`利⽤`createElement`⽅法创建`VNode`，它定义在`src/core/vdom/create-elemenet.js`中：

```javascript
export function createElement (
  context: Component,
  tag: any,
  data: any,
  children: any,
  normalizationType: any,
  alwaysNormalize: boolean
): VNode | Array<VNode> {
  // 
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children
    children = data
    data = undefined
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE
  }
  return _createElement(context, tag, data, children, normalizationType)
}

```

`createElement`⽅法实际上是对`_createElement`⽅法的封装，它允许传⼊的参数更加灵活，在处理这些参数后，调⽤真正创建`VNode`的函数`_createElement`	：

```javascript

```

​	`_createElement`⽅法有5个参数，context表⽰`VNode`的上下⽂环境，它是`Component`类 型；tag表⽰标签，它可以是⼀个字符串，也可以是⼀个Component；data表⽰`VNode`的数 据，它是⼀个`VNodeData`类型，可以在`flow/vnode.js`中找到它的定义，这⾥先不展开说；`children`表⽰当前`VNode`的⼦节点，它是任意类型的，它接下来需要被规范为标准的`VNode` 数组；`normalizationType`表⽰⼦节点规范的类型，类型不同规范的⽅法也就不⼀样，它主要是参 考`render`函数是编译⽣成的还是⽤户⼿写的。

主要分析2个重点的流程	——	children的规范化以及`VNode`的创建。 

### children的规范化 

由于`Virtual	DOM`实际上是⼀个树状结构，每⼀个`VNode`可能会有若⼲个⼦节点，这些⼦节点应该也是`VNode`	的类型。`_createElement`接收的第4个参数children是任意类型的，因此我们需要把它们规范成`VNode`类型。 

这⾥根据`normalizationType`的不同，调⽤了`normalizeChildren(children)`和`simpleNormalizeChildren(children)`⽅法，它们的定义都在`src/core/vdom/helpers/normalzie-children.js`中：

```javascript
export function simpleNormalizeChildren (children: any) {
  for (let i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children)
    }
  }
  return children
}


export function normalizeChildren (children: any): ?Array<VNode> {
  return isPrimitive(children)
    ? [createTextVNode(children)]
    : Array.isArray(children)
      ? normalizeArrayChildren(children)
      : undefined
}
```

`simpleNormalizeChildren`⽅法调⽤场景是`render`函数当函数是编译⽣成的。理论上编译⽣成的children都已经是`VNode`类型的，但这⾥有⼀个例外，就是`functional	component`函数式组件 返回的是⼀个数组⽽不是⼀个根节点，所以会通过`Array.prototype.concat`⽅法把整个children数组打平，让它的深度只有⼀层。

`normalizeChildren`⽅法的调⽤场景有2种，**⼀个场景**是**render函数是⽤户⼿写的**，当`children`只有⼀个节点的时候，`Vue.js`从接⼝层⾯允许⽤户把`children`写成基础类型⽤来创建单个简单的⽂本节点，这种情况会调⽤`createTextVNode`创建⼀个⽂本节点的`VNode`；**另⼀个场景**是 当**编译`slot`、`v-for`**的时候会产⽣嵌套数组的情况，会调⽤`normalizeArrayChildren`⽅法。

```javascript
function normalizeArrayChildren (children: any, nestedIndex?: string): Array<VNode> {
  const res = []
  let i, c, lastIndex, last
  for (i = 0; i < children.length; i++) {
    c = children[i]
    if (isUndef(c) || typeof c === 'boolean') continue
    lastIndex = res.length - 1
    last = res[lastIndex]
    //  nested
    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, `${nestedIndex || ''}_${i}`)
        // merge adjacent text nodes
        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + (c[0]: any).text)
          c.shift()
        }
        res.push.apply(res, c)
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c)
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c))
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text)
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) &&
          isDef(c.tag) &&
          isUndef(c.key) &&
          isDef(nestedIndex)) {
          c.key = `__vlist${nestedIndex}_${i}__`
        }
        res.push(c)
      }
    }
  }
  return res
}

```

### `VNode`的创建

回到`createElement`函数，规范化children后，接下来会去创建⼀个`VNode`的实例：

```javascript
let vnode, ns
  if (typeof tag === 'string') {
    let Ctor
    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag)
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      if (process.env.NODE_ENV !== 'production' && isDef(data) && isDef(data.nativeOn)) {
        warn(
          `The .native modifier for v-on is only valid on components but it was used on <${tag}>.`,
          context
        )
      }
      // 通过new Node创建vnode
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      )
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag)
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      // 通过new Node创建vnode
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      )
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children)
  }
```

我们⼤致了解了`createElement`创建`VNode`的过程，每个`VNode`有children，children每个元素也是⼀个	`VNode`，这样就形成了⼀个`VNode	Tree`，它很好的描述了我们的`DOM	Tree`。 回到		`mountComponent`函数的过程，我们已经知道`vm._render`是如何创建了⼀个`VNode`，接下来 就是要把这个	`VNode`渲染成⼀个真实的`DOM`并渲染出来，这个过程是通过`vm._update`完成的， 接下来分析⼀下这个过程。

## update

`Vue`的_update是实例的⼀个私有⽅法，它被调⽤的时机有2个，⼀个是⾸次渲染，⼀个是数据更新的时候；

`_update`⽅法的作⽤是把`VNode`渲染成真实的DOM，它的定义在`src/core/instance/lifecycle.js`		中：

```javascript
export function lifecycleMixin (Vue: Class<Component>) {
  Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {
    const vm: Component = this
    const prevEl = vm.$el
    const prevVnode = vm._vnode
    const restoreActiveInstance = setActiveInstance(vm)
    vm._vnode = vnode
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode)
    }
    restoreActiveInstance()
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  }

  Vue.prototype.$forceUpdate = function () {
    const vm: Component = this
    if (vm._watcher) {
      vm._watcher.update()
    }
  }

  Vue.prototype.$destroy = function () {
    const vm: Component = this
    if (vm._isBeingDestroyed) {
      return
    }
    callHook(vm, 'beforeDestroy')
    vm._isBeingDestroyed = true
    // remove self from parent
    const parent = vm.$parent
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm)
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown()
    }
    let i = vm._watchers.length
    while (i--) {
      vm._watchers[i].teardown()
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--
    }
    // call the last hook...
    vm._isDestroyed = true
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null)
    // fire destroyed hook
    callHook(vm, 'destroyed')
    // turn off all instance listeners.
    vm.$off()
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null
    }
    // release circular reference (#6759)
    if (vm.$vnode) {
      vm.$vnode.parent = null
    }
  }
}
```

`_update`的核⼼就是调⽤`vm.__patch__`⽅法，这个⽅法实际上在不同的平台，⽐如`web`和`weex`上的定义是不⼀样的，因此在web平台中它的定义在`src/platforms/web/runtime/index.js`中：

```JavaScript
Vue.prototype.__patch__ = inBrowser ? patch : noop
```

可以看到，甚⾄在`web`平台上，是否是服务端渲染也会对这个⽅法产⽣影响。因为在服务端渲染中， 没有真实的浏览器`DOM`环境，所以不需要把`VNode`最终转换成	DOM，因此是⼀个空函数，⽽在浏览 器端渲染中，它指向了`patch`⽅法，它的定义在`src/platforms/web/runtime/patch.js`	中：

```javascript
import * as nodeOps from 'web/runtime/node-ops'
import { createPatchFunction } from 'core/vdom/patch'
import baseModules from 'core/vdom/modules/index'
import platformModules from 'web/runtime/modules/index'

// the directive module should be applied last, after all
// built-in modules have been applied.
const modules = platformModules.concat(baseModules)

export const patch: Function = createPatchFunction({ nodeOps, modules })
```

该⽅法的定义是调⽤`createPatchFunction`⽅法的返回值，这⾥传⼊了⼀个对象，包含`nodeOps`参数和		`modules`参数。其中，`nodeOps`封装了⼀系列DOM操作的⽅法，modules定义了⼀些模 块的钩⼦函数的实现，我们这⾥先不详细介绍，来看⼀下`createPatchFunction`的实现，它定义在`src/core/vdom/patch.js`		中：

```javascript
// 在`createPatchFunction`函数内部会对一些钩子进行激活
const hooks = ['create', 'activate', 'update', 'remove', 'destroy']

 for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = []
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]])
      }
    }
  }
// 后续代码过多，不便粘贴。
```

`createPatchFunction`内部定义了⼀系列的辅助⽅法，最终返回了⼀个`patch`⽅法，这个⽅法就赋值给了		`vm._update`函数⾥调⽤的`vm.__patch__`。 

`patch`是跟平台相关的，在`Web`和`Weex`环境，它们把虚拟`DOM`映射到“平台 `DOM`”	的⽅法是不同的，并且对	“DOM”	包括的属性模块创建和更新也不尽相同。因此每个平台都有各⾃的`nodeOps`和`modules`，它们的代码需要托管在`src/platforms`这个⼤⽬录下。 ⽽不同平台的`patch`的主要逻辑部分是相同的，所以这部分公共的部分托管在`core`这个⼤⽬录 下。差异化部分只需要通过参数来区别，这⾥⽤到了⼀个函数柯⾥化的技巧，通过`createPatchFunction`把差异化参数提前固化，这样不⽤每次调⽤`patch`的时候都传递`nodeOps`和`modules`了，这种编程技巧也⾮常值得学习。 在这⾥，`nodeOps`表⽰对	“平台 `DOM`”	的⼀些操作⽅法，modules表⽰平台的⼀些模块，它们会在 整个patch过程的不同阶段执⾏相应的钩⼦函数。

通过`emptyNodeAt`⽅法把`oldVnode`转换成`VNode`对象，然后再调⽤`createElm`⽅法，这个 ⽅法在这⾥⾮常重要，来看⼀下它的实现：

```JavaScript
function createElm (
    vnode,
    insertedVnodeQueue,
    parentElm,
    refElm,
    nested,
    ownerArray,
    index
  ) {
    // ...

    const data = vnode.data
    const children = vnode.children
    const tag = vnode.tag
    if (isDef(tag)) {
      if (process.env.NODE_ENV !== 'production') {
        if (data && data.pre) {
          creatingElmInVPre++
        }
        // 没有注册组件便使用，就会进行报错
        if (isUnknownElement(vnode, creatingElmInVPre)) {
          warn(
            'Unknown custom element: <' + tag + '> - did you ' +
            'register the component correctly? For recursive components, ' +
            'make sure to provide the "name" option.',
            vnode.context
          )
        }
      }
      // createElement方法内部的实现就是通过原生的document.createElement方法
      vnode.elm = vnode.ns
        ? nodeOps.createElementNS(vnode.ns, tag)
        : nodeOps.createElement(tag, vnode)
      setScope(vnode)

      // weex平台
      if (__WEEX__) {
        // ...
      } else {
        // 创建子节点
        // 在createChildren方法中遍历子虚拟节点，递归调用createElm方法，
        // 这是一种常用的深度优先遍历算法。遍历的过程中会把vnode.elm作为父容器的DOM节点占位符传入
        createChildren(vnode, children, insertedVnodeQueue)
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue)
        }
        // 通过insert方法
        // 最后调⽤insert⽅法把DOM插⼊到⽗节点中，因为是递归调⽤，
        // ⼦元素会优先调⽤insert，所以整个vnode树节点的插⼊顺序是先⼦后⽗
        insert(parentElm, vnode.elm, refElm)
      }

    }
      // ...
  }
```



# 三、组件化（后续更新）

`Vue.js`另⼀个核⼼思想是组件化。所谓组件化，就是把⻚⾯拆分成多个组件(component)，每个组件依赖的`CSS`、`JavaScript`、模板、图⽚等资源放在⼀起开发和维护。组件是资源独⽴的，组件在系统内部可复⽤，组件和组件之间可以嵌套。 

从源码的⾓度来分析`Vue`的组件内部是如何⼯作的，只有了解了内部的⼯作原理，才能让我们使⽤它的时候更加得⼼应⼿。 接下来我们会⽤`Vue-cli`初始化的代码为例，来分析⼀下`Vue`组件初始化的⼀个过程。

```javascript
import	Vue	from	'vue' 
import	App	from	'./App.vue'

new Vue({
  router,
  store,
  //	这⾥的	h	是	createElement	⽅法
  render: h => h(App)
}).$mount('#app') // 将实例挂载到id为app的div上
```

这段代码也是通过`render`函数去渲染的，不同的这次通过`createElement`传的参数是⼀个组件⽽不是⼀个原⽣的标签，那么接下来我们就开始分析这⼀过程。

## `createComponent`

在分析`createElement`的实现的时候，它最终会调⽤`_createElement`⽅法，其中有 ⼀段逻辑是对参数`tag`的判断，如果是⼀个普通的`html`标签，像上⼀章的例⼦那样是⼀个普通的 div，则会实例化⼀个普通`VNode`节点，否则通过`createComponent`⽅法创建⼀个组件`VNode`。它定义在`src/core/vdom/createComponent.js`中

```javascript

```

`createComponent`的逻辑也会有⼀些复杂，但是分析源码⽐较推荐的是只分析核⼼流 程，分⽀流程可以之后针对性的看，所以这⾥针对组件渲染这个`case`主要就3个关键步骤： 构造⼦类构造函数，安装组件钩⼦函数和实例化`vnode`。

### 构造⼦类构造函数

```javascript
// createComponent.js


// baseCtor访问到的是Vue
const baseCtor = context.$options._base

// 将Ctor转化成一个新的构造器，该构造器拥有和Vue一样的能力
if (isObject(Ctor)) {
  Ctor = baseCtor.extend(Ctor)
}
```

我们在编写⼀个组件的时候，通常都是创建⼀个普通对象，还是以我们的`App.vue`为例，代码如下：

```JavaScript
import	HelloWorld	from	'./components/HelloWorld'
export	default	{		
  name:	'app',		
  components:	{				
    HelloWorld		
  } 
} 
```

这⾥`export`的是⼀个对象，所以`createComponent`⾥的代码逻辑会执⾏到`baseCtor.extend(Ctor)`，在这⾥	`baseCtor`实际上就是`Vue`，这个的定义是在最开始初始化`Vue` 的阶段，在`src/core/global-api/index.js`	中的`initGlobalAPI`函数有这么⼀段逻辑：

```javascript
Vue.options._base	=	Vue 
```

这⾥定义的是	`Vue.option`，⽽我们的`createComponent`取的是`context.$options`，实际上在		`src/core/instance/init.js`⾥`Vue`原型上的`_init`函数中有这 么⼀段逻辑：

```JavaScript
vm.$options	=	mergeOptions(		
  resolveConstructorOptions(vm.constructor),		
  options	||	{},		
  vm 
) 
```

这样就把`Vue`上的⼀些`option`扩展到了`vm.$option`	上，所以我们也就能通过`vm.$options._base`拿到`Vue`这个构造函数了。`mergeOptions`的实现我们会在后续章节中具体分析，现在只需要理解它 的功能是把`Vue`构造函数的`options`和⽤户传⼊的`options`做⼀层合并，到`vm.$options`上。 

在了解了`baseCtor`指向了`Vue`之后，我们来看⼀下`Vue.extend`函数的定义，在`src/core/global-api/extend.js`中。

```javascript
// 代码有大量删减


Vue.extend = function (extendOptions: Object): Function {
    extendOptions = extendOptions || {}
    // 该this指向Vue，而不是vm实例
    const Super = this
    const SuperId = Super.cid
    const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {})
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId]
    }
    // 拿到组件name属性
    const name = extendOptions.name || Super.options.name
    if (process.env.NODE_ENV !== 'production' && name) {
      // 在开发环境下会对组件name做一层校验
      validateComponentName(name)
    }

    const Sub = function VueComponent (options) {
      // this._init方法实际上是执行到了Vue.prototype._init方法上
      this._init(options)
    }
    // 后续操作都是为了让Sub拥有和Vue一样的能力

    // 将子构造器的原型指向父的原型
    Sub.prototype = Object.create(Super.prototype)
    // 把构造器指回Sub
    Sub.prototype.constructor = Sub
    Sub.cid = cid++
    Sub.options = mergeOptions(
      Super.options,
      extendOptions
    )
    Sub['super'] = Super
  
    // 中间删除的代码会对子构造器做一系列初始化操作
  
    cachedCtors[SuperId] = Sub
    // 返回Sub构造器
    return Sub
  }
}
```

`Vue.extend`的作⽤就是构造⼀个`Vue`的⼦类，它使⽤⼀种⾮常经典的原型继承的⽅式把⼀个纯对象转换⼀个继承于`Vue`的构造器`Sub`并返回，然后对`Sub`这个对象本⾝扩展了⼀些属性，如扩展`options`、添加全局`API`等，让`Sub`拥有和`Vue`一样的能力。并且对配置中的`props`和`computed`做了初始化⼯作；最后对于 这个`Sub`构造函数做了缓存，避免多次执⾏`Vue.extend`的时候对同⼀个⼦组件重复构造。 这样当我们去实例化`Sub`的时候，就会执⾏`this._init`逻辑再次⾛到了`Vue`实例的初始化逻 辑，实例化⼦组件的逻辑在之后的章节会介绍。

```javascript
const Sub = function VueComponent (options) {
  // this._init方法实际上是执行到了Vue.prototype._init方法上
  this._init(options)
}
```

### 安装组件钩⼦函数

```javascript
// createComponent.js

// 安装一些组件的钩子
installComponentHooks(data)
```

我们之前提到`Vue.js`使⽤的`Virtual DOM`参考的是开源库`snabbdom`，它的⼀个特点是在`VNode`的`patch`流程中对外暴露了各种时机的钩⼦函数，⽅便我们做⼀些额外的事情，`Vue.js`也是充分利⽤这⼀ 点，在初始化⼀个`Component`类型的`VNode`的过程中实现了⼏个钩⼦函数.

```javascript
// createComponent.js

function installComponentHooks (data: VNodeData) {
  const hooks = data.hook || (data.hook = {})
  for (let i = 0; i < hooksToMerge.length; i++) {
    const key = hooksToMerge[i]
    const existing = hooks[key]
    const toMerge = componentVNodeHooks[key]
    if (existing !== toMerge && !(existing && existing._merged)) {
      hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge
    }
  }
}
```

整个`installComponentHooks`的过程就是把`componentVNodeHooks`的钩⼦函数合并到`data.hook`，在	`VNode`执⾏`patch`的过程中执⾏相关的钩⼦函数，具体的执⾏我们稍后在介绍`patch`过程中会详细介绍。这⾥要注意的是合并策略，在合并过程中，如果某个时机的钩⼦已经存在`data.hook`中，那么通过执⾏`mergeHook`函数做合并，这个逻辑很简单，就是在最终执⾏的时候，依次执⾏这两个钩⼦函数即可。 

### 实例化`VNode`

```javascript
// createComponent.js

const name = Ctor.options.name || tag
const vnode = new VNode(
  `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`,
  data, undefined, undefined, undefined, context,
  { Ctor, propsData, listeners, tag, children },
  asyncFactory
)

return vnode
```

最后⼀步⾮常简单，通过`new VNode`实例化⼀个`vnode`并返回。需要注意的是和普通元素节点的`vnode`不同，组件的`vnode`是没有`children`的，这点很关键，在之后的`patch`过程中我们会再提。

### 总结

分析了`createComponent`的实现，了解到它在渲染⼀个组件的时候的3个关键逻辑：构造⼦类构造函数，安装组件钩⼦函数和实例化`vnode`。`createComponent`后返回的是组件`vnode`，它也⼀样⾛到`vm._update`⽅法，进⽽执⾏了`patch`函数，我们在上⼀章对`patch`函 数做了简单的分析，那么下⼀节我们会对它做进⼀步的分析。

## `path`（后续更新）

当我们通过`createComponent`创建了组件`VNode`，接下来会⾛到`vm._update`，执⾏`vm.__patch__`去把	`VNode`转换成真正的`DOM`节点。这个过程我们在之前已经分析过了，但是针对⼀个普通的`VNode`节点，接下来我们来看看组件的`VNode`会有哪些不⼀样的地⽅。 

`patch`的过程会调⽤`createElm`创建元素节点，回顾⼀下`createElm`的实现，它的定义在	`src/core/vdom/patch.js`中：

```javascript
// 删除了大量代码，只保留了关键逻辑

function createElm (
  vnode,
  insertedVnodeQueue,
  parentElm,
  refElm,
  nested,
  ownerArray,
  index
) {
  // ...
	if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
		return
  }
  // ...
}
```

### `createComponent`

```javascript
// src/core/vdom/patch.js

function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
  // 首先对vnode.data做了一些判断
  let i = vnode.data
  if (isDef(i)) {
    // 在里面做keepAlive等相关操作
    const isReactivated = isDef(vnode.componentInstance) && i.keepAlive
    if (isDef(i = i.hook) && isDef(i = i.init)) {
      // 如果vnode是⼀个组件	VNode，那么条件会满⾜，并且得到i就是init钩⼦函数
      i(vnode, false /* hydrating */)
    }
    // after calling the init hook, if the vnode is a child component
    // it should've created a child instance and mounted it. the child
    // component also has set the placeholder vnode's elm.
    // in that case we can just return the element and be done.
    if (isDef(vnode.componentInstance)) {
      initComponent(vnode, insertedVnodeQueue)
      insert(parentElm, vnode.elm, refElm)
      if (isTrue(isReactivated)) {
        reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)
      }
      return true
    }
  }
}
```

我们在创建组件`VNode`的时候合并钩⼦函数中就包含`init`钩⼦函数，定义在`src/core/vdom/create-component.js`中：

```javascript
init (vnode: VNodeWithData, hydrating: boolean): ?boolean {
  if (
    vnode.componentInstance &&
    !vnode.componentInstance._isDestroyed &&
    vnode.data.keepAlive
  ) {
    // kept-alive components, treat as a patch
    const mountedNode: any = vnode // work around flow
    componentVNodeHooks.prepatch(mountedNode, mountedNode)
  } else {
    // 通过createComponentInstanceForVnode创建一个Vue实例
    const child = vnode.componentInstance = createComponentInstanceForVnode(
      vnode,
      activeInstance
    )
    // 调用$mount方法挂载子组件
    child.$mount(hydrating ? vnode.elm : undefined, hydrating)
  }
}
```

# 四、深入响应式原理

## 响应式对象

### `initState`

在`Vue`的初始化阶段，`_init`⽅法执⾏的时候，会执⾏`initState(vm)`⽅法，它的定义在	src/core/instance/state.js中。

```javascript
// 初始化props、methods、data、computed与watchers
export function initState (vm: Component) {
  vm._watchers = []
  const opts = vm.$options
  // 初始化props
  if (opts.props) initProps(vm, opts.props)
  // 初始化方法
  if (opts.methods) initMethods(vm, opts.methods)
  // 初始化data
  if (opts.data) {
    initData(vm)
  } else {
    // 该组件没有data的时候绑定一个空对象
    observe(vm._data = {}, true /* asRootData */)
  }
  // 初始化computed
  if (opts.computed) initComputed(vm, opts.computed)
  // 初始化watchers
  if (opts.watch) initWatch(vm, opts.watch)
}
```

先重点分析`props`和`data`

```javascript
// 初始化props
function initProps (vm: Component, propsOptions: Object) {
  const propsData = vm.$options.propsData || {}
  const props = vm._props = {}
  // 缓存属性的key，使得将来能直接使用数组的索引值来更新props来替代动态地枚举对象
  const keys = vm.$options._propKeys = []
  // 根据$parent是否存在来判断当前是否是根结点
  const isRoot = !vm.$parent
  // root instance props should be converted
  // 根结点会给shouldConvert赋true，根结点的props应该被转换
  observerState.shouldConvert = isRoot
  for (const key in propsOptions) {
    // props的key值存入keys（_propKeys）中
    keys.push(key)
    // 验证prop,不存在用默认值替换，类型为bool则声称true或false，
    // 当使用default中的默认值的时候会将默认值的副本进行observe
    const value = validateProp(key, propsOptions, propsData, vm)
    //  istanbul ignore else 
    if (process.env.NODE_ENV !== 'production') {
      // 判断是否是保留字段，如果是则发出warning
      if (isReservedProp[key] || config.isReservedAttr(key)) {
        warn(
          `"${key}" is a reserved attribute and cannot be used as component prop.`,
          vm
        )
      }
      // 通过使用defineReactive方法将每个props对应的值变为响应式
      defineReactive(props, key, value, () => {
        // 由于父组件重新渲染的时候会重写prop的值，
        // 所以应该直接使用prop来作为一个data或者计算属性的依赖。
        // https://cn.vuejs.org/v2/guide/components.html#字面量语法-vs-动态语法
        
        if (vm.$parent && !observerState.isSettingProps) {
          warn(
            `Avoid mutating a prop directly since the value will be ` +
            `overwritten whenever the parent component re-renders. ` +
            `Instead, use a data or computed property based on the prop's ` +
            `value. Prop being mutated: "${key}"`,
            vm
          )
        }
      })
    } else {
      defineReactive(props, key, value)
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    // Vue.extend()期间，静态prop已经在组件原型上代理了，我们只需要在这里进行代理prop
    if (!(key in vm)) {
      proxy(vm, `_props`, key)
    }
  }
  observerState.shouldConvert = true
}
```

`props`的初始化主要过程，就是遍历定义的`props`配置。遍历的过程主要做两件事情：⼀个是调⽤`defineReactive`⽅法把每个`prop`对应的值变成响应式，可以通过`vm._props.xxx`访问到定 义`prop`s中对应的属性。对于`defineReactive`⽅法，我们稍后会介绍；另⼀个是通过`proxy`把`vm._props.xxx`的访问代理到`vm.xxx`上，我们稍后也会介绍。 

### `initData`

```javascript
// 初始化data
function initData (vm: Component) {

  // 得到data数据
  let data = vm.$options.data
  // 组件中的data是一个函数，通过执行data函数，拿到返回的数据对象
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {}

  //  对对象类型进行严格检查，只有当对象是纯javascript对象的时候返回true
  if (!isPlainObject(data)) {
    data = {}
    process.env.NODE_ENV !== 'production' && warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    )
  }
  // proxy data on instance
  // 遍历data对象，拿到data中的所有属性keys
  const keys = Object.keys(data)
  const props = vm.$options.props
  let i = keys.length

  //遍历data中的数据
  while (i--) {

    // 保证data中的key不与props中的key重复，props优先，如果有冲突会产生warning
    if (props && hasOwn(props, keys[i])) {
      process.env.NODE_ENV !== 'production' && warn(
        `The data property "${keys[i]}" is already declared as a prop. ` +
        `Use prop default value instead.`,
        vm
      )
    } else if (!isReserved(keys[i])) {
      // 判断是否是保留字段

      // 这里是我们前面讲过的代理，将data上面的属性代理到了vm实例上
      proxy(vm, `_data`, keys[i])
    }
  }
  // observe data
  // 从这里开始我们要observe了，开始对数据进行绑定，
  // 这里有尤大大的注释asRootData，这步作为根数据，
  // 下面会进行递归observe进行对深层对象的绑定。
 	// 因为这里传入的data是组件中根data，所以传入true，否则传入false
  observe(data, true /* asRootData */)
}
```

`data`的初始化主要过程也是做两件事，⼀个是对定义`data`函数返回对象的遍历，通过`proxy`把每⼀个值`vm._data.xxx`都代理到`vm.xxx`上；另⼀个是调⽤`observe`⽅法观测整个`data`的变化，把`data`也变成响应式，可以通过`vm._data.xxx`访问到定义data返回函数中对应的 属性，observe我们稍后会介绍。 可以看到，⽆论是`props`或是data的初始化都是把它们变成响应式对象，这个过程我们接触到⼏个函数，接下来我们来详细分析它们。 

### `proxy`

代理的作⽤是把`props`和`data`上的属性代理到`vm`实例上，这也就是为什么⽐如我们定义了如下`props`，却可以通过`vm`实例访问到它。

```javascript
let comP = {
  props: {
    msg: 'hello'
  },
  methods : {
    say () {
      console.log(this.msg)
    }
  }
}
```

我们可以在`say`函数中通过`this.msg`访问到我们定义在`props`中的`msg`，这个过程发⽣在`proxy`阶段：

```javascript
//通过proxy函数将_data（或者_props等）上面的数据代理到vm上，
// 这样就可以用vm.text代替vm._data.text了。
export function proxy (target: Object, sourceKey: string, key: string) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  }
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val
  }
  Object.defineProperty(target, key, sharedPropertyDefinition)
}
```

### 	`observe`函数

`observe`的功能就是⽤来监测数据的变化，它的定义在`src/core/observer/index.js`中：

```javascript
//  尝试创建一个Observer实例（__ob__），
// 如果成功创建Observer实例则返回新的Observer实例，
// 如果已有Observer实例则返回现有的Observer实例。
export function observe (value: any, asRootData: ?boolean): Observer | void {
  // 如果属性已经不是对象了，则直接返回
  if (!isObject(value)) {
    return
  }
  let ob: Observer | void
  // 这里用__ob__这个属性来判断是否已经有Observer实例，
  // 如果没有Observer实例则会新建一个Observer实例并赋值给__ob__这个属性，
  // 如果已有Observer实例则直接返回该Observer实例
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__
  } else if (
      // 这里的判断是为了确保value是单纯的对象，而不是函数或者是Regexp等情况。
      // 而且该对象在shouldConvert的时候才会进行Observer。这是一个标识位，
      // 避免重复对value进行Observer
    observerState.shouldConvert &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    ob = new Observer(value)
  }
  if (asRootData && ob) {
    //  如果是根数据则计数，后面Observer中的observe的asRootData非true
    ob.vmCount++
  }
  return ob
}

```

`observe`⽅法的作⽤就是给⾮`VNode`的对象类型数据添加⼀个`Observer`，如果已经添加过则直接返回，否则在满⾜⼀定条件下去实例化⼀个`Observer`对象实例

### `Observer`类

`Observer`是⼀个类，它的作⽤是给对象的属性添加`getter`和`setter`，⽤于依赖收集和派发更新：

```JavaScript
// 每个被观察到对象被附加上观察者实例，一旦被添加，
// 观察者将为目标对象加上getter\setter属性，进行依赖收集以及调度更新。
export class Observer {
  value: any;
  dep: Dep;
  vmCount: number; // number of vms that has this object as root $data

  constructor (value: any) {
    this.value = value
    this.dep = new Dep()
    this.vmCount = 0
    // 通过def方法将Observer实例绑定到data的__ob__属性上面去，
    // 之前说过observe的时候会先检测是否已经有__ob__对象存放Observer实例了，
    // def方法定义可以参考https://github.com/vuejs/vue/blob/dev/src/core/util/lang.js#L16 
    def(value, '__ob__', this)
    if (Array.isArray(value)) {
      // 如果data中有属性是数组，将修改后可以截获响应的数组方法替换掉该数组的原型中的原生方法，
      // 达到监听数组数据变化响应的效果。这里如果当前浏览器支持__proto__属性，
      // 则直接覆盖当前数组对象原型上的原生数组方法，如果不支持该属性，
      // 则直接覆盖数组对象的原型。
      const augment = hasProto
        ? protoAugment  /*直接覆盖原型的方法来修改目标对象*/
        : copyAugment   /*定义（覆盖）目标对象或数组的某一个方法*/
      augment(value, arrayMethods, arrayKeys)

      /*如果是数组则需要遍历数组的每一个成员进行observe*/
      this.observeArray(value)
    } else {
      /*如果是对象则直接walk进行绑定*/
      this.walk(value)
    }
  }

  // 遍历每一个对象并且在它们上面绑定getter与setter。
  // 这个方法只有在value的类型是对象的时候才能被调用
  walk (obj: Object) {
    const keys = Object.keys(obj)
    // walk方法会遍历对象的每一个属性进行defineReactive绑定,在defineReactive方法中
    // 会对数据对象的子属性递归执行observer方法,以便使得对深层对象的数据绑定
    for (let i = 0; i < keys.length; i++) {
      defineReactive(obj, keys[i], obj[keys[i]])
    }
  }

  // 对一个数组的每一个成员进行observe
  observeArray (items: Array<any>) {
    for (let i = 0, l = items.length; i < l; i++) {
      // 数组需要遍历每一个成员进行observe
      observe(items[i])
    }
  }
}
```

`Observer`的构造函数，⾸先通过`defineReactive`实例化`Dep`对象，这块稍后会介绍，接着通过执⾏def函数把⾃⾝实例添加到数据对象`value`的`__ob__`属性上，`def`的定义在`src/core/util/lang.js`中：

```javascript
export function def (obj: Object, key: string, val: any, enumerable?: boolean) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  })
}
```

回到`Observer`的构造函数，接下来会对`value`做判断，对于数组，将使用可以截获响应的数组方法替换掉该数组的原型中的原生方法。达到监听数组数据变化响应的效果。然后调⽤`observeArray`⽅法， 否则对纯对象调⽤`walk`⽅法。可以看到`observeArray`是遍历数组再次调⽤`observe`⽅法，⽽`walk`⽅法是遍历对象的`key`调⽤`defineReactive`⽅法

### `defineReactive`

`defineReactive`的功能就是定义⼀个响应式对象，给对象动态添加`getter`和`setter`，它的定义在	`src/core/observer/index.js`中：

```javascript
export function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: Function
) {
  // 在闭包中定义一个dep对象（收集和派发依赖的仓库）
  const dep = new Dep()

  // 拿到传入对象的一些定义
  const property = Object.getOwnPropertyDescriptor(obj, key)
  if (property && property.configurable === false) {
    return
  }

  // 如果之前该数据对象已经预设了getter以及setter函数则将其取出来，
  // 新定义的getter/setter中会将其执行，保证不会覆盖之前已经定义的getter/setter。
  const getter = property && property.get
  const setter = property && property.set

  // 对象的子对象递归进行observe并返回子节点的Observer对象
  let childOb = observe(val)

  // 将数据变成响应式对象
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      // 如果原本对象拥有getter方法则优先执行原有的getter方法
      const value = getter ? getter.call(obj) : val
      // Dep.target为一个全局的Watcher
      if (Dep.target) {
        // 进行依赖收集(后续进行详细分析)
        dep.depend()
        if (childOb) {
          // 子对象进行依赖收集，其实就是将同一个watcher观察者实例放进了两个depend中，
          // 一个是正在本身闭包中的depend，另一个是子元素的depend
          childOb.dep.depend()
        }
        if (Array.isArray(value)) {
          // 是数组则需要对每一个成员都进行依赖收集，如果数组的成员还是数组，则递归。
          dependArray(value)
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      // 通过getter方法获取当前值，与新值进行比较，一致则不需要执行下面的操作
      const value = getter ? getter.call(obj) : val
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      if (process.env.NODE_ENV !== 'production' && customSetter) {
        customSetter()
      }
      if (setter) {
        // 如果原本对象拥有setter方法则优先执行原有的setter方法
        setter.call(obj, newVal)
      } else {
        val = newVal
      }
      // 新的值需要重新进行observe，保证数据响应式
      childOb = observe(newVal)
      // dep对象通知所有的观察者(后续进行详细分析)
      dep.notify()
    }
  })
}
```

`defineReactive`函数最开始初始化`Dep`对象的实例，接着拿到`obj`的属性描述符，然后对⼦对 象递归调⽤`observe`⽅法，这样就保证了⽆论`obj`的结构多复杂，它的所有⼦属性也能变成响应式的对象，这样我们访问或修改obj中⼀个嵌套较深的属性，也能触发getter和setter。最后利⽤`Object.defineProperty`去给`obj`的属性`key`添加`getter`和`setter`。

响应式对象的核⼼就是利⽤`Object.defineProperty`给数据添加了getter和 setter，⽬的就是为了在我们访问数据以及写数据的时候能⾃动执⾏⼀些逻辑：getter做的事情是依赖收 集，setter做的事情是派发更新。

## 依赖收集

响应式对象`getter`相关的逻辑就是做依赖收集 

```javascript
// 代码有大量删减

export function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: Function
) {
  // 在闭包中定义一个dep对象(依赖收集和派发的仓库)
  const dep = new Dep()


	// 省略

  // 将数据变成响应式对象
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      // 如果原本对象拥有getter方法则优先执行原有的getter方法
      const value = getter ? getter.call(obj) : val
      // Dep.target为一个全局的Watcher
      if (Dep.target) {
        // 进行依赖收集(后续进行详细分析)
        dep.depend()
        if (childOb) {
          // 子对象进行依赖收集，其实就是将同一个watcher观察者实例放进了两个depend中，
          // 一个是正在本身闭包中的depend，另一个是子元素的depend
          childOb.dep.depend()
        }
        if (Array.isArray(value)) {
          // 是数组则需要对每一个成员都进行依赖收集，如果数组的成员还是数组，则递归。
          dependArray(value)
        }
      }
      return value
    },
    // 省略
  })
}
```

这段代码我们只需要关注2个地⽅，⼀个是`const dep =	new	Dep()`实例化⼀个`Dep`的实例，另 ⼀个是在get函数中通过`dep.depend`做依赖收集，

### `Dep`

`Dep`是整个getter依赖收集的核⼼，它的定义在`src/core/observer/dep.js`中：

```javascript
export default class Dep {
  static target: ?Watcher;
  id: number;
  subs: Array<Watcher>;

  constructor () {
    this.id = uid++
    this.subs = []
  }

  // 添加一个观察者对象
  addSub (sub: Watcher) {
    this.subs.push(sub)
  }

  // 移除一个观察者对象
  removeSub (sub: Watcher) {
    remove(this.subs, sub)
  }

  // 依赖收集，当存在Dep.target的时候添加观察者对象
  depend () {
    if (Dep.target) {
      Dep.target.addDep(this)
    }
  }

  // 通知所有订阅者
  notify () {
    // stabilize the subscriber list first
    const subs = this.subs.slice()
    for (let i = 0, l = subs.length; i < l; i++) {
      subs[i].update()
    }
  }
}

// 依赖收集完需要将Dep.target设为null，防止后面重复添加依赖。
Dep.target = null
const targetStack = []

// 将watcher观察者实例设置给Dep.target，用以依赖收集。同时将该实例存入target栈中
export function pushTarget (_target: Watcher) {
  if (Dep.target) targetStack.push(Dep.target)
  Dep.target = _target
}

// 将观察者实例从target栈中取出并设置给Dep.target
export function popTarget () {
  Dep.target = targetStack.pop()
}
```

`Dep`是⼀个Class，它定义了⼀些属性和⽅法，这⾥需要特别注意的是它有⼀个静态属性target，这是⼀个全局唯⼀`Watcher`，这是⼀个⾮常巧妙的设计，因为在同⼀时间只能有⼀个全局的Watcher被计算，另外它的⾃⾝属性`subs`也是`Watcher`的数组。`Dep`实际上就是对`Watcher`的⼀种管理，`Dep`脱离Watcher单独存在是没有意义的。

### `Watcher`

`Watcher`是⼀个Class，在它的构造函数中，定义了⼀些和`Dep`相关的属性`src/core/observer/watcher.js`

```javascript
// 代码有大量删减，只写出了和Dep相关的部分属性

this.deps = []
this.newDeps = []
this.depIds = new Set()
this.newDepIds = new Set()
```

其中，`this.deps`和`this.newDeps`表⽰`Watcher`实例持有的`Dep`实例的数组；⽽`this.depIds`和`this.newDepIds`分别代表`this.deps`和`this.newDeps`的id。

#### 过程分析

当对数据对象的访问会触发他们的getter⽅法。`Vue`的`mount`过程是通过`mountComponent`函数，其中有⼀段⽐较重要的逻辑，⼤ 致如下：

```javascript
updateComponent	=	()	=>	{		
  vm._update(vm._render(),	hydrating) 
} 
new	Watcher(vm,	updateComponent,	noop,	{
	before	()	{				
    if	(vm._isMounted)	{						
      callHook(vm,	'beforeUpdate')				
    }		
  } 
},	true	/*	isRenderWatcher	*/) 
```

> 从`Vue.js2.0`开始，它引入了虚拟DOM，将粒度调整为中等粒度，即一个状态所绑定的依赖不再是具体的DOM节点，而是一个组件。这样状态发生变化后，会通知到组件，组件内部再使用虚拟DOM进行比对。这样可以大大降低依赖数量，从而降低依赖追踪所消耗的内存。

当我们去实例化⼀个渲染watcher的时候，⾸先进⼊watcher的构造函数逻辑，然后会执⾏它的`this.get()`⽅法，进⼊get函数，⾸先会执⾏：

```javascript
pushTarget(this)	
```

`pushTarget`的定义在`src/core/observer/dep.js`中：

```JavaScript
export	function	pushTarget	(_target:	Watcher)	{		
  if	(Dep.target)	targetStack.push(Dep.target)		
  Dep.target	=	_target 
} 
```

实际上就是把`Dep.target`赋值为当前的渲染watcher并压栈（为了恢复⽤）。接着⼜执⾏了：

```javascript
value	=	this.getter.call(vm,	vm)
```

`this.getter`对应就是`updateComponent`函数，这实际上就是在执⾏：

```javascript
vm._update(vm._render(),	hydrating) 
```

它会先执⾏`vm._render()`⽅法，因为之前分析过这个⽅法会⽣成渲染`VNode`，并且在这个过程中 会对`vm`上的数据访问，这个时候就触发了数据对象的getter。 

在`vm._render()`过程中，会触发所有数据的getter，这样实际上已经完成了⼀个依赖收集的过程。

#### 依赖清空

当`vm`的依赖收集完成之后，还会有一个依赖清空的操作

```javascript
this.cleanupDeps() 
```

考虑到`Vue`是数据驱动的，所以每次数据变化都会重新render，那么`vm._render()`⽅法⼜会再次执⾏，并再次触发数据的getters，所以`Wathcer`在构造函数中会初始化2个`Dep`实例数 组，`newDeps`	表⽰新添加的`Dep`实例数组，⽽`deps`	表⽰上⼀次添加的`Dep`实例数组。 在执⾏`cleanupDeps`函数的时候，会⾸先遍历`deps`，移除对`dep`的订阅，然后把`newDepIds和depIds`交换，`newDep和deps`交换，并把`newDepIds和newDeps`清空。 

为什么需要做`deps`订阅的移除呢，在添加`deps`的订阅过程，已经能通过id去重避免重复 订阅了。 

考虑到⼀种场景，我们的模板会根据v-if去渲染不同⼦模板a和b，当我们满⾜某种条件的时候渲染a的时候，会访问到a中的数据，这时候我们对a使⽤的数据添加了	getter，做了依赖收集，那么当 我们去修改a的数据的时候，理应通知到这些订阅者。那么如果我们⼀旦改变了条件渲染了b模板， ⼜会对b使⽤的数据添加了getter，如果我们没有依赖移除的过程，那么这时候我去修改a模板的数 据，会通知a数据的订阅的回调，这显然是有浪费的。 

### `Observer`、`Dep`和`Watcher`之间的关系

![image-20191130203246614](http://img.lijiawei0627.xyz/img/image-20191130203246614.png)

#### Observer 「响应式」

`Vue`中用`Observer`类来管理上述响应式化`Object.defineProperty`的过程。它最终会将`this.data`也就是我们在`Vue`代码中定义的`data`属性全部进行「响应式」绑定。

#### `Dep` 「依赖管理」

通过`defineReactive`方法将`data`中的数据进行响应式后，虽然可以监听到数据的变化了，那我们怎么处理通知视图就更新呢？`Dep`就是帮我们收集依赖的

```javascript
<div id="app">
  <p>{{ message }}</p>
	<p>{{ message }}</p>
  <p v-text='message'></p>
<div>
    
new Vue({
	el: '#app',
  data: {
    text: 'hello world',
    message: 'hello vue'
  }
})
// 这里虽然data中有text和message属性，但是只有message被渲染到页面上，至于text无论怎么变化都影响不到视图的展示，因此我们仅仅对message进行收集即可，可以避免一些无用的工作。
// 这个时候message的Dep就收集到了一个依赖，这一个依赖就是用来管理data中message变化的。
```

当使用watch属性时，也就是开发者自定义的监听某个data中属性的变化。比如监听message的变化，message变化时我们就要通知到watch这个钩子，让它去执行回调函数。

这个时候message的`Dep`就收集到了第二个依赖，第二个依赖就是用来管理watch中message变化的。

```javascript
watch: {
  message: function (val, oldVal) {
    console.log(`new ${val}`)
  }
}
```

当开发者自定义`computed`计算属性时，如下`messageT`属性，是依赖`message`的变化的。因此`message`变化时我们也要通知到`computed`，让它去执行回调函数。 （但是前提是`messageT`的变化会影响到页面渲染）这个时候`message`的`Dep`就收集到了三个依赖，这个依赖就是用来管理`computed`中`message`变化的。

```javascript
computed: {
	messageT () {
    return this.message + '!'
  }
}
```

**一个属性可能有多个依赖，每个响应式数据都有一个`Dep`来管理它的依赖。**

#### Watcher 「中介」（观察者）

Watcher是观察者，那么谁是订阅者呢，例如，`data`中的`message`可以是一个观察者，而`template`中使用到每一个`message`都可以是一个订阅者

`Watcher`就是类似中介的角色，比如`message`就有三个中介，当`message`变化，就通知这三个中介，他们就去执行各自需要做的变化。

`Watcher`能够控制自己属于哪个，是`data`中的属性的还是`watch`，或者是`computed`，`Watcher`自己有统一的更新入口，只要你通知它，就会执行对应的更新方法。

因此我们可以推测出，`Watcher`必须要有的2个方法。一个就是通知变化，另一个就是被收集起来到`Dep`中去。



`Dep和Watcher`之间为多对多的关系(此处对于多对多关系，暂时存在疑点)

* 每个`data`属性 ——>一个 `Dep` ——> 有n个`Watcher`（n>=1）

* 一个表达式 —— > 一个`Watcher` —— > n个`Dep`（多层表达式,比如`msg.name`）(n>=1)

* 执行过程：`vm.name` = `'abc'` ——> `data`中name属性值变化——> `name`的set()调用 ——> `dep`——> 相关的所有`Watcher`——>`cb()`——> `update`

## 派发更新

了解了响应式数据依赖收集过程，收集的⽬的就是为了当我们修改数据的时候， 可以对相关的依赖派发更新。主要是关注`defineReactive`中的`setter`部分

```javascript
set: function reactiveSetter (newVal) {
  // 通过getter方法获取当前值，与新值进行比较，一致则不需要执行下面的操作
  const value = getter ? getter.call(obj) : val
  if (newVal === value || (newVal !== newVal && value !== value)) {
    return
  }
  if (process.env.NODE_ENV !== 'production' && customSetter) {
    customSetter()
  }
  if (setter) {
    // 如果原本对象拥有setter方法则优先执行原有的setter方法
    setter.call(obj, newVal)
  } else {
    val = newVal
  }
  // 新的值需要重新进行observe，保证数据响应式
  childOb = observe(newVal)
  // dep对象通知所有的观察者(后续进行详细分析)
  dep.notify()
}
```

`setter`的逻辑有2个关键的点，⼀个是`childOb	=	!shallow	&&	observe(newVal)`，如果`shallow`为`false`的情况，会对新设置的值变成⼀个响应式对象；另⼀个是`dep.notify()`，通知所有的订阅者。接下来先详细了解派发更新这一过程

### 过程分析

当我们在组件中对响应的数据做了修改，就会触发`setter`的逻辑，最后调⽤`dep.notify()`⽅法，	它 是`Dep`的⼀个实例⽅法，定义在`src/core/observer/dep.js`中：

```javascript
export default class Dep {

  // 删除了大量代码

  // 通知该dep中所有订阅者
  notify () {
    // stabilize the subscriber list first
    // 拿到subs的一个副本
    const subs = this.subs.slice()
    // 遍历subs，对subs中的每一项进行updata操作
    for (let i = 0, l = subs.length; i < l; i++) {
      subs[i].update()
    }
  }
}
```

`notify`逻辑主要是遍历`subs`，也就是Watcher的实例数组，然后调⽤每⼀个`Watcher`的update⽅法，它的定义在`src/core/observer/watcher.js`中：

```javascript
// 代码有大量删除

export default class Watcher {
  
  // ...
  
  // 调度者接口，当依赖发生改变的时候进行回调。
  update () {
    if (this.lazy) {
      this.dirty = true
    } else if (this.sync) {
      // 同步则执行run直接渲染视图
      this.run()
    } else {
      // 异步推送到观察者队列中，下一个tick时调用。
      queueWatcher(this)
    }
  }
  
  // ...
}

```

这⾥对于`Watcher`有三种不同状态，会执⾏不同的逻辑，`computed`和`sync`等状态的分析之后再进行详细分析，在⼀般组件数据更新的场景，会⾛到最后⼀个`queueWatcher(this)`的逻 辑，`queueWatcher`的定义在		`src/core/observer/scheduler.js`中：

```javascript
export function queueWatcher (watcher: Watcher) {
  // 获取watcher的id
  const id = watcher.id
  // 检验id是否存在，已经存在则直接跳过，不存在则标记哈希表has，用于下次检验
  if (has[id] == null) {
    has[id] = true
    if (!flushing) {
      // 如果没有flush掉，直接push到队列中即可
      queue.push(watcher)
    } else {
      let i = queue.length - 1
      while (i >= 0 && queue[i].id > watcher.id) {
        i--
      }
      queue.splice(Math.max(i, index) + 1, 0, watcher)
    }
    // 在nextTick中一次性执⾏flushSchedulerQueue来派发队列中的watcher更新，
    // 而不是每次一有watcher就进行派发，这样可以节省性能
    if (!waiting) {
      waiting = true
      nextTick(flushSchedulerQueue)
    }
  }
}
```

这⾥引⼊了⼀个队列的概念，这也是`Vue`在做派发更新的时候的⼀个优化的点，它并不会每次数据改变时就直接触发`watcher`的回调，⽽是把这些`watcher`先添加到⼀个队列⾥，然后在`nextTick`后执行`flushSchedulerQueue`。 

> 只要观察到数据变化，`Vue` 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。 然后，在下一个的事件循环“tick”中，`Vue` 刷新队列并执行实际 (已去重的) 工作。 

这⾥有⼏个细节要注意⼀下，⾸先⽤has对象保证同⼀个`Watcher`只添加⼀次；接着对`flushing`的判断，else部分的逻辑稍后我会讲；最后通过`wating`保证对`nextTick(flushSchedulerQueue)`的调⽤逻辑只有⼀次，另外`nextTick`的实现后续分许，⽬前就可以理解它是在下⼀个tick，也就是异步的去执⾏`flushSchedulerQueue`。

我们可以看一个例子：

#### `this.$nextTick()`

```javascript
<div class="app">
  <div ref="msgDiv">{{msg}}</div>
  <div v-if="msg1">Message got outside $nextTick: {{msg1}}</div>
  <div v-if="msg2">Message got inside $nextTick: {{msg2}}</div>
  <div v-if="msg3">Message got outside $nextTick: {{msg3}}</div>
  <button @click="changeMsg">
    Change the Message
  </button>
</div>

new Vue({
  el: '.app',
  data: {
    msg: 'Hello Vue.',
    msg1: '',
    msg2: '',
    msg3: ''
  },
  methods: {
    changeMsg() {
      this.msg = "Hello world."
      this.msg1 = this.$refs.msgDiv.innerHTML
      this.$nextTick(() => {
        this.msg2 = this.$refs.msgDiv.innerHTML
      })
      this.msg3 = this.$refs.msgDiv.innerHTML
    }
  }
})
```

 **点击前** ：

 ![img](https://upload-images.jianshu.io/upload_images/3985563-b6bb266285e8d232.png?imageMogr2/auto-orient/strip|imageView2/2/w/152/format/webp) 

**点击后：**

 ![img](https://upload-images.jianshu.io/upload_images/3985563-f49bff3190724514.png?imageMogr2/auto-orient/strip|imageView2/2/w/341/format/webp) 

 从上可以得知：`msg1`和`msg3`显示的内容还是变换之前的，而`msg2`显示的内容是变换之后的。其根本原因是因为`Vue`中DOM更新是异步的,React的数据更新也是异步。 

`flushSchedulerQueue`的实现，它的定义在`src/core/observer/scheduler.js`中。

```javascript
// nextTick的回调函数，在下一个tick时flush掉两个队列同时运行watchers
function flushSchedulerQueue () {
  flushing = true
  let watcher, id

  // 给queue排序，这样做可以保证：
  // 1.组件更新的顺序是从父组件到子组件的顺序，因为父组件总是比子组件先创建。
  // 2.一个组件的user watchers比render watcher先运行，
  // 因为user watchers往往比render watcher更早创建
  // 3.如果一个组件在父组件watcher运行期间被销毁，它的watcher执行将被跳过。
  queue.sort((a, b) => a.id - b.id)

  // 这里不用index = queue.length;index > 0;
  //  index--的方式写是因为不要将length进行缓存，因为在执行处理现有watcher对象期间，
  // 更多的watcher对象可能会被push进queue
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index]
    id = watcher.id
    // 将has的标记删除
    has[id] = null
    // 执行watcher
    watcher.run()
    /*
      在测试环境中，检测watch是否在死循环中
      比如这样一种情况
      watch: {
        test () {
          this.test++;
        }
      }
      持续执行了一百次watch代表可能存在死循环
    */
    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn(
          'You may have an infinite update loop ' + (
            watcher.user
              ? `in watcher with expression "${watcher.expression}"`
              : `in a component render function.`
          ),
          watcher.vm
        )
        break
      }
    }
  }

  // 得到队列的拷贝
  const activatedQueue = activatedChildren.slice()
  const updatedQueue = queue.slice()

  /*重置调度者的状态*/
  resetSchedulerState()

  // 使子组件状态都改编成active同时调用activated钩子
  callActivatedHooks(activatedQueue)
  /*调用updated钩子*/
  callUpdateHooks(updatedQueue)

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush')
  }
}
```

这⾥有⼏个重要的逻辑要梳理⼀下，对于⼀些分⽀逻辑如`keep-alive`组件相关和之前提到过的`updated`钩⼦函数的执⾏会略过。

*  队列排序：`queue.sort((a,	b)	=>	a.id	-	b.id)`对队列做了从⼩到⼤的排序，这么做主要有以下要确保以下 ⼏点： 
  * 1.组件的更新由⽗到⼦；因为⽗组件的创建过程是先于⼦的，所以watcher的创建也是先⽗后⼦， 执⾏顺序也应该保持先⽗后⼦。
  *  2.⽤户的⾃定义watcher要优先于渲染watcher执⾏；因为⽤户⾃定义watcher是在渲染watcher之前创建的。 
  * 3.如果⼀个组件在⽗组件的watcher执⾏期间被销毁，那么它对应的watcher执⾏都可以被跳过，所以⽗组件的watcher应该先执⾏。

* 队列遍历 

  在对`queue`排序后，接着就是要对它做遍历，拿到对应的watcher，执⾏`watcher.run()`。这 ⾥需要注意⼀个细节，在遍历的时候每次都会对`queue.length`求值，因为在`watcher.run()`的 时候，很可能⽤户会再次添加新的`watcher`，这样会再次执⾏到`queueWatcher`。这时候`flushing`为	true，就会执⾏到else的逻辑，然后就会从后往前找，找到第⼀个待 插⼊watcher的id⽐当前队列中watcher的id⼤的位置。把		watcher按照id的插⼊到队列 中，因此queue的⻓度发送了变化。 

* 状态恢复 ：这个过程就是执⾏`resetSchedulerState`函数，它的定义在`src/core/observer/scheduler.js`	中。

```javascript
// 重置调度者的状态
function resetSchedulerState () {
  queue.length = activatedChildren.length = 0
  has = {}
  if (process.env.NODE_ENV !== 'production') {
    circular = {}
  }
  waiting = flushing = false
}
```

把这些控制流程状态的⼀些变量恢复到初始值，把`watcher`队列清空。 

最后执行`watcher.run()`

```javascript
 // 调度者工作接口，将被调度者回调。
  run () {
    if (this.active) {
      //  get操作在获取value本身也会执行getter从而调用update更新视图 
      const value = this.get()
      if (
        value !== this.value ||
        // Deep watchers and watchers on Object/Arrays should fire even
        // when the value is the same, because the value may
        // have mutated.
            
        // 即便值相同，拥有Deep属性的观察者以及在对象／数组上的观察者应该被触发更新，
        // 因为它们的值可能发生改变。
        isObject(value) ||
        this.deep
      ) {
        // set new value
        const oldValue = this.value
        // 设置新的值
        this.value = value

        // 触发回调
        if (this.user) {
          try {
            this.cb.call(this.vm, value, oldValue)
          } catch (e) {
            handleError(e, this.vm, `callback for watcher "${this.expression}"`)
          }
        } else {
          this.cb.call(this.vm, value, oldValue)
        }
      }
    }
  }
```

### 总结

`Vue`数据修改派发更新的过程也有了认识，实际上就是当数据发⽣变化的 时候，触发	setter	逻辑，把在依赖过程中订阅的的所有观察者，也就是watcher	，都触发它们的update过程，这个过程⼜利⽤了队列做了进⼀步优化，在`nextTick`后执⾏所有watcher的run，最后执⾏它们的回调函数。

## 检测变化的注意事项 

### 对象添加属性 

对于使⽤`Object.defineProperty`实现响应式的对象，当我们去给这个对象添加⼀个新的属性的时候，是不能够触发它的setter的，⽐如：

```javascript
var vm = new Vue({
  data: {
    msg: {
      name: 'lijiawei',
      age: 20
    }
  }
})

// 此时给msg对象添加一个wife属性，是非响应式数据
vm.msg.wife = 'ymg';

// 注：但是如果通过直接给msg赋值一个新对象，通过侦测msg值的变化，进行派发更新，
// 在派发更新的过程中会再次对msg数据对象进行observer处理，生成一个新的响应式对象。
// 以此达到对对象中添加新属性的监听(不推荐此方法)
vm.msg = {
  name: 'lijiawei',
  age: 20,
  wife: 'ymh'
}

// Vue.set方法
vm.$set(vm.msg, 'wife', 'ymh') // 给msg对象添加一个响应式属性wife
```

但是添加新属性的场景我们在平时开发中会经常遇到，那么`Vue`为了解决这个问题，定义了⼀个全局 `API Vue.set`⽅法，它在`src/core/global-api/index.js`中初始化：

```javascript
Vue.set	=	set 
```

这个set⽅法的定义在`src/core/observer/index.js`中：

```javascript
export function set (target: Array<any> | Object, key: any, val: any): any {
  // 如果传入数组则在指定位置插入val
  if (Array.isArray(target) && typeof key === 'number') {
    target.length = Math.max(target.length, key)
    // 因为数组不需要进行响应式处理，数组会修改七个Array原型上的方法来进行响应式处理
    target.splice(key, 1, val)
    return val
  }
  // 如果是一个对象，并且已经存在了这个key则直接返回
  if (hasOwn(target, key)) {
    target[key] = val
    return val
  }
  //  获得target的Oberver实例
  const ob = (target : any).__ob__

    // _isVue 一个防止vm实例自身被观察的标志位 ，_isVue为true则代表vm实例，也就是this
    // vmCount判断是否为根节点，存在则代表是data的根节点，
    // Vue 不允许在已经创建的实例上动态添加新的根级响应式属性(root-level reactive property)
  if (target._isVue || (ob && ob.vmCount)) {
    /*  
      Vue 不允许在已经创建的实例上动态添加新的根级响应式属性(root-level reactive property)。
      https://cn.vuejs.org/v2/guide/reactivity.html#变化检测问题
    */
    process.env.NODE_ENV !== 'production' && warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    )
    return val
  }
  if (!ob) {
    target[key] = val
    return val
  }
  // 为对象defineProperty上在变化时通知的属性
  defineReactive(ob.value, key, val)
  ob.dep.notify()
  return val
}
```

`set`⽅法接收3个参数，target可能是数组或者是普通对象，key代表的是数组的下标或者是对 象的键值，val代表添加的值。

1. ⾸先判断如果target是数组且key是⼀个合法的下标，则之前 通过splice去添加进数组然后返回，这⾥的splice其实已经不仅仅是原⽣数组的splice了， 稍后我会详细介绍数组的逻辑。
2. 接着⼜判断key已经存在于target中，则直接赋值返回，因为这 样的变化是可以观测到了。
3. 接着再获取到`target.__ob__`并赋值给`ob`，之前分析过它是在Observer的构造函数执⾏的时候初始化的，表⽰Observer的⼀个实例，如果它不存在，则说明target不是⼀个响应式的对象，则直接赋值并返回。
4. 最后通过`defineReactive(ob.value,	key, val)`把新添加的属性变成响应式对象，然后再通过`ob.dep.notify()`⼿动的触发依赖通知。

### 数组

`Vue`不能检测到以下变动的数组： 

1. 当你利⽤索引直接设置⼀个项时，例如：`vm.items[indexOfItem]	=	newValue`
2. 2.当你修改数组的⻓度时，例如：`vm.items.length = newLength`

对于第⼀种情况，可以使⽤：`Vue.set(example1.items, indexOfItem, newValue)`；⽽对于第⼆种情况，可以使⽤`vm.items.splice(newLength)`。 

我们刚才也分析到，对于`Vue.set`	的实现，当target是数组的时候，也是通过`target.splice(key, 1, val)`来添加的。那么这⾥的splice到底有什么⿊魔法，能让添加的对 象变成响应式的呢。 其实之前我们也分析过，在通过observe⽅法去观察对象的时候会实例化Observer，在它的构造函数中是专门对数组做了处理。

### Array的变化侦测

在`ES6`之前，`JavaScript`并没有给数组提供元编程能力，也就是没有提供可以拦截原型方法的能力，但是我们可以通过自定义去覆盖原生的原型方法.

![image-20191129160537153](http://img.lijiawei0627.xyz/img/image-20191129160537153.png)

每当使用Array原型上的方法操作数组时，其实执行的都是拦截器中提供的方法，比如`push`方法。然后在拦截器中使用原生Array的原型方法去操作数组。

有了拦截器之后，想要它生效，就必须用它去覆盖`Array.prototype`.但是我们又不能直接覆盖，因为这样会污染全局的`Array`。我们希望拦截操作只会对那些被侦测了变化的响应式数据生效，也就是说希望拦截器只覆盖那些响应式数组的原型。

```javascript
// 代码有大量删减

export class Observer {
  
  // 。。。
  constructor (value: any) {
    
    // 。。。
    
    if (Array.isArray(value)) {
      // 如果data中有属性是数组，将修改后可以截获响应的数组方法替换掉该数组的原型中的原生方法，
      // 达到监听数组数据变化响应的效果。这里如果当前浏览器支持__proto__属性，
      // 则直接覆盖当前数组对象原型上的原生数组方法，如果不支持该属性，
      // 则直接覆盖数组对象的原型。
      // value.__proto__ = arrayMethods
      const augment = hasProto
        ? protoAugment  /*直接覆盖原型的方法来修改目标对象*/
        : copyAugment   /*定义（覆盖）目标对象或数组的某一个方法*/
      // 将拦截器2赋值给value.__proto__，通过__proto__可以巧妙地实现覆盖value原型的功能
      augment(value, arrayMethods, arrayKeys)

      /*如果是数组则需要遍历数组的每一个成员进行observe*/
      this.observeArray(value)
    } else {
      /*如果是对象则直接walk进行绑定*/
      this.walk(value)
    }
  }

	// 。。。
}
```

![image-20191129161928627](http://img.lijiawei0627.xyz/img/image-20191129161928627.png)

>  从`ECMAScript 2015` 开始，JavaScript 获得了 [`Proxy`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy) 和 [`Reflect`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect) 对象的支持，允许你拦截并定义基本语言操作的自定义行为（例如，属性查找，赋值，枚举，函数调用等）。借助这两个对象，你可以在 JavaScript 元级别进行编程。 

## 计算属性 VS 侦听属性 

### `computed`

计算属性的初始化是发⽣在`Vue`实例初始化阶段的`initState`函数中，执⾏了

```javascript
if (opts.computed)	initComputed(vm,	opts.computed)
```

`initComputed`的定义在`src/core/instance/state.js`中：

```javascript
// 初始化computed
function initComputed (vm: Component, computed: Object) {
  const watchers = vm._computedWatchers = Object.create(null)

  for (const key in computed) {
    const userDef = computed[key]

    // 计算属性可能是一个function，也有可能设置了get以及set的对象。
    // 可以参考 https://cn.vuejs.org/v2/guide/computed.html#计算-setter
    let getter = typeof userDef === 'function' ? userDef : userDef.get
    if (process.env.NODE_ENV !== 'production') {
      // getter不存在的时候抛出warning并且给getter赋空函数
      if (getter === undefined) {
        warn(
          `No getter function has been defined for computed property "${key}".`,
          vm
        )
        getter = noop
      }
    }

    // 为计算属性创建一个内部的监视器Watcher，保存在vm实例的_computedWatchers中
    // 这里的computedWatcherOptions参数传递了一个computed为true，会使得watch实例的dirty为true
    watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions)

    // 判断如果key不是vm的属性，则调⽤defineComputed(vm,	key,	userDef)
    // 否则判断计算属性对于的key是否已经被data或者prop所占⽤，如果是的话则在开发环境报相应的警告。 
    if (!(key in vm)) {
      // 定义计算属性
      defineComputed(vm, key, userDef)
    } else if (process.env.NODE_ENV !== 'production') {
      // 如果计算属性与已定义的data或者props中的名称冲突则发出warning
      if (key in vm.$data) {
        warn(`The computed property "${key}" is already defined in data.`, vm)
      } else if (vm.$options.props && key in vm.$options.props) {
        warn(`The computed property "${key}" is already defined as a prop.`, vm)
      }
    }
  }
}
```

函数⾸先创建`vm._computedWatchers`为⼀个空对象，接着对`computed`对象做遍历，拿到计算属性的每⼀个`userDef`，然后尝试获取这个`userDef`对应的`getter`函数，拿不到则在开发环境下 报警告。接下来为每⼀个`getter`创建⼀个watcher	，这个watcher和渲染watcher有⼀点很 ⼤的不同，它是⼀个`computed watcher`，因为`const	computedWatcherOptions = { computed: true }`	。`computed	watcher`	和普通watcher的差别稍后介绍。最后对判断如果key不是`vm`的属性，则调⽤`defineComputed(vm,	key, userDef)`	，否则判断计算属性对于的`key`是否 已经被data或者prop所占⽤，如果是的话则在开发环境报相应的警告。 

#### `defineComputed`的实现：

```javascript
// 定义计算属性
export function defineComputed (target: any, key: string, userDef: Object | Function) {
  if (typeof userDef === 'function') {
    // 创建计算属性的getter
    sharedPropertyDefinition.get = createComputedGetter(key)

    // 当userDef是一个function的时候是不需要setter的，所以这边给它设置成了空函数。
    // 因为计算属性默认是一个function，只设置getter。
    // 当需要设置setter的时候，会将计算属性设置成一个对象。
    sharedPropertyDefinition.set = noop
  } else {
    // get不存在则直接给空函数，如果存在则查看是否有缓存cache，
    // 没有依旧赋值get，有的话使用createComputedGetter创建
    sharedPropertyDefinition.get = userDef.get
      ? userDef.cache !== false
        ? createComputedGetter(key)
        : userDef.get
      : noop
    // 如果有设置set方法则直接使用，否则赋值空函数
    sharedPropertyDefinition.set = userDef.set
      ? userDef.set
      : noop
  }
  // defineProperty上getter与setter
  Object.defineProperty(target, key, sharedPropertyDefinition)
}
```

这段逻辑很简单，其实就是利⽤`Object.defineProperty`给计算属性对应的key值添加getter和 setter，setter	通常是计算属性是⼀个对象，并且拥有set⽅法的时候才有，否则是⼀个空函数。在平 时的开发场景中，计算属性有setter的情况⽐较少，我们重点关注⼀下getter部分，缓存的配置也先忽 略，最终getter对应的是`createComputedGetter(key)`的返回值，来看⼀下它的定义：

#### `createComputedGetter`

```javascript
// 创建计算属性的getter
function createComputedGetter (key) {
  return function computedGetter () {
    const watcher = this._computedWatchers && this._computedWatchers[key]
    if (watcher) {
      // 实际是脏检查，在计算属性中的依赖发生改变的时候dirty会变成true，
      // 在get的时候重新计算计算属性的输出值
      if (watcher.dirty) {
        watcher.evaluate()
      }
      //  依赖收集
      if (Dep.target) {
        watcher.depend()
      }
      return watcher.value
    }
  }
}
```

`createComputedGetter`	返回⼀个函数`computedGetter`，它就是计算属性对应的getter。 

### `Watch`（后续更新）

侦听属性的初始化也是发⽣在`Vue`的实例初始化阶段的`initState`函数中，在computed初始化 之后，执⾏了：

```javascript
if	(opts.watch	&&	opts.watch	!==	nativeWatch)	{		
	initWatch(vm,	opts.watch) 
} 
```

## 原理图



![image-20191129171637510](http://img.lijiawei0627.xyz/img/image-20191129171637510.png)

# 五、编译

模板到真实`DOM`渲染的过程，中间有一个环节是把模板编译成`render`函数，这个过程称作编译。虽然可以为组件编写render函数，但是编写`template`模板更加直观，更符合我们的开发习惯。

`Vue.js`提供了两个版本，一个是`Runtime + Compiler`的，一个是Runtime only的。前者是包含编译代码的，可以把编译过程放在运⾏时做，后者是不包含编译代码的，需要借助`webpack`的`vue-loader`事先把模板编译成render函数。 对编译过程的了解会让我们对`Vue`的指令、内置组件等有更好的理 解。

## 编译入口

当我们使⽤	Runtime + Compiler的`Vue.js`，它的⼊⼝是`src/platforms/web/entry-runtime-withcompiler.js`，看⼀下它对$mount函数的定义：

```JavaScript
Vue.prototype.$mount = function (
  // 可以传入字符串el或者直接传入元素
  el?: string | Element,
  hydrating?: boolean
): Component {
  // 如果el存在，就调用query方法对el进行转换，返回dom对象赋给el
  el = el && query(el)

  // 对el做了限制，Vue不能挂载在body、html这样的根节点上，否则会报错
  if (el === document.body || el === document.documentElement) {
    process.env.NODE_ENV !== 'production' && warn(
      `Do not mount Vue to <html> or <body> - mount to normal elements instead.`
    )
    return this
  }

  const options = this.$options
  // 当没有直接使用render函数时，解析模板/el并转换为呈现函数
  if (!options.render) {
    let template = options.template
    // 判断是否定义了template
    if (template) {
      if (typeof template === 'string') {
        // 当template是以"#tmp1"这样的形式存在时，
        // 通过idToTemplate方法（内部再次使用了query(el)方法）去获取template组件
        if (template.charAt(0) === '#') {
          template = idToTemplate(template)
          // 当没有找到对应的元素时，会进行报错
          if (process.env.NODE_ENV !== 'production' && !template) {
            warn(
              `Template element not found or is empty: ${options.template}`,
              this
            )
          }
        } 
      } else if (template.nodeType) { 
        // <template></template>
        // 拿到template的innerHTML
        template = template.innerHTML
      } else {
        if (process.env.NODE_ENV !== 'production') {
          warn('invalid template option:' + template, this)
        }
        return this
      }
    } else if (el) { // 当没有定义template时，通过getOuterHTML(el)去获取dom相关的字符串
      template = getOuterHTML(el) // template最终是字符串类型
    }
  }
  // 通过上面转换之后得到的template来得到render方法
  if (template) {
      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile')
      }
			// 生成render方法
      const { render, staticRenderFns } = compileToFunctions(template, {
        outputSourceRange: process.env.NODE_ENV !== 'production',
        shouldDecodeNewlines,
        shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this)
      options.render = render
      options.staticRenderFns = staticRenderFns

      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile end')
        measure(`vue ${this._name} compile`, 'compile', 'compile end')
      }
    }
  // 执行runtime中的$mount方法
  return mount.call(this, el, hydrating)
}
```

这段函数逻辑之前分析过，关于编译的⼊⼝就是在这⾥：

```javascript
// 生成render方法
const { render, staticRenderFns } = compileToFunctions(template, {
  outputSourceRange: process.env.NODE_ENV !== 'production',
  shouldDecodeNewlines,
  shouldDecodeNewlinesForHref,
  delimiters: options.delimiters,
  comments: options.comments
}, this)
options.render = render
options.staticRenderFns = staticRenderFns
```

`compileToFunctions`⽅法就是把模板template编译⽣成render以及`staticRenderFns`，它 的定义在		`src/platforms/web/compiler/index.js`中：

```javascript
import { baseOptions } from './options'
import { createCompiler } from 'compiler/index'

const { compile, compileToFunctions } = createCompiler(baseOptions)

export { compile, compileToFunctions }
```

可以看到`compileToFunctions`方法实际上是`createCompiler`方法的返回值，该方法接受一个编译配置参数，接下来我们看一下`createCompiler`方法的定义，在`src/compiler/index.js`中：

```javascript
export const createCompiler = createCompilerCreator(function baseCompile (
  template: string,
  options: CompilerOptions
): CompiledResult {
  const ast = parse(template.trim(), options)
  if (options.optimize !== false) {
    optimize(ast, options)
  }
  const code = generate(ast, options)
  return {
    ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  }
})
```

`compileToFunctions`的最终定义，它接收3个参数：编译模板template， 编译配置options和`Vue`实例`vm`。核⼼的编译过程就⼀⾏代码：

```javascript
const	compiled	=	compile(template,	options)
```

整个编译流程，主要就是执行了如下几个逻辑

* 解析模板字符串生成`AST`(抽象语法树)

  ```javascript
  const ast = parse(template.trim(), options)
  ```

* 优化语法树

  ```javascript
  optimize(ast, options)
  ```

* 生成代码

  ```javascript
  const code = generate(ast, options)
  ```

`Vue.js`在不同的平台下都会有编译的过程，因此编译过程中的依赖的配置`baseOptions`会有所不同。

## `parse`

编译过程⾸先就是对模板做解析，⽣成`AST`，它是⼀种抽象语法树，是对源代码的抽象语法结构的树 状表现形式。在很多编译技术中，如babel编译`ES6`的代码都会先⽣成`AST`。

这个过程是⽐较复杂的，它会⽤到⼤量正则表达式对字符串解析。

### 例子：

```html
<ul	:class="bindCls"	class="list"	v-if="isShow">				
  <li	v-for="(item,index)	in	data"	@click="clickItem(index)">{{item}}:{{index}}</ li> </ul> 
```

```JavaScript
ast	=	{		
  'type':	1,		
  'tag':	'ul',		
  'attrsList':	[],		
  'attrsMap':	{				
    ':class':	'bindCls',				
    'class':	'list',				
    'v-if':	'isShow'		
  },		
  'if':	'isShow',		
  'ifConditions':	[{				
    'exp':	'isShow',				
    'block':	//	ul	ast	element		
  }],		
  'parent':	undefined,		
  'plain':	false,		
  'staticClass':	'list',		
  'classBinding':	'bindCls',		
  'children':	[{				
    'type':	1,				
    'tag':	'li',				
    'attrsList':	[{						
      'name':	'@click',						
      'value':	'clickItem(index)'				
    }],				
    'attrsMap':	{						
      '@click':	'clickItem(index)',						
      'v-for':	'(item,index)	in	data'					
    },				
    'parent':	//	ul	ast	element				
    'plain':	false,				
    'events':	{
			'click':	{								
        'value':	'clickItem(index)'						
      }				
    },				
    'hasBindings':	true,				
    'for':	'data',				
    'alias':	'item',				
    'iterator1':	'index',				
    'children':	[						
      'type':	2,						
      'expression':	'_s(item)+":"+_s(index)',						
      'text':	'{{item}}:{{index}}',						
      'tokens':	[								
        {'@binding':'item'},								
        ':',								
        {'@binding':'index'}						
      ]				
    ]		
  }] 
}
```

可以看到，⽣成的`AST`是⼀个树状结构，每⼀个节点都是⼀个`ast element`，除了它⾃⾝的⼀些属性，还维护了它的⽗⼦关系，如parent指向它的⽗节点，children指向它的所有⼦节点。

## 整体流程 

