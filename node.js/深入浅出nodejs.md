# 一、`Node`简介

为什么会选择`JavaScript`：考虑到**高性能、事驱动、没有历史包袱**这3个主要因素，JavaScript为了Node的实现语言。

## `Node`给`JavaScript` 带来的意义

`Node`不处理`UI`，但用与浏览器相同的机制和原理运行。`Node`打破了过去`JavaScript`只能在浏览器中运行的局面。前后端编程环境统一，可以大大降低前后端转换需要的上下文交换代价。

## `Node`的特点

### 异步`IO`

![image-20200325123843534](http://img.lijiawei0627.xyz/img/image-20200325123843534.png)

![image-20200325123851445](http://img.lijiawei0627.xyz/img/image-20200325123851445.png)

在`Node`中，绝大多数的操作都以异步的方式进行调用。

下面的两个文件读取任务的耗时取决于最慢的那个文件读取的耗时

```javascript
fs.readFile('/path1', (err, file) => {
  console.log('读取文件1完成');
})
fs.readFile('/path2', (err, file) => {
  console.log('读取文件2完成')
})
```

而对于同步`I/O`而言，它们的耗时是两个任务的耗时之和。

### 事件与回调函数

```javascript
var http = require('http')
var querystring = require('querystring')

// 侦听服务器的request事件
http.createServer((req, res) => {
  var postData = ''
  req.setEncoding('utf8')
  // 侦听请求的data事件
  req.on('data', (chunk) => {
    postData += chunk;
  });
  // 侦听请求的end事件
  req.on('end', () => {
    res.end(postData);
  })
}).listen(8080)
console.log('服务器启动完成')
```

**与其他的Web后端编程语言相比，Node除了异步和事件外，回调函数是一大特色。纵观下来，回调函数也是最好的接受异步调用返回数据的方式。**

### 单线程

`Node`保持了`JavaScript`在浏览器中单线程的特点。而且在`Node`中，`JavaScript`与其他线程是无法共享任何状态的。单线程最大的好处是不用像多线程编程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文交换所带来的的性能上的开销。

#### 弱点

* 无法利用多核`CPU`
* 错误会引起整个应用的退出，应用的健壮性值得考虑
* 大量计算占用`CPU`导致无法继续调用异步`I/O`。在Node中，长时间的CPU占用也会导致后续的异步`I/O`发不出调用，已完成的异步I/O的回调函数也会得不到及时执行。 

在浏览器中，`Web Workers`能够创建工作线程来进行计算，以解决`JavaScript`大计算阻塞`UI`渲染的问题。**`Node`采用了与`Web Workers`相同的思路来解决单线程中大计算量的问题：`child_process`。子进程的出现，意味着Node可以从容地应对单线程在健壮性和无法利用多核`CPU`方面的问题**

### 跨平台

## `Node`的应用场景

### `I/O`密集型

说`Node`擅长`I/O`密集型的应用场景基本上是没人反对的。`Node`面向网络且最擅长并行`I/O`，能够有效地组织起更多的硬件资源，从而提供更多好的服务。

**`I/O`密集的优势主要在于`Node`利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用更少**

### `CPU`密集型

在CPU密集的应用场景中，Node是否能胜任呢？实际上，`V8`的执行效率是十分高的。单以执行效率来做评判，`V8`的执行效率是毋庸置疑的。

#### 存在的问题

`CPU`密集型应用给Node带来的挑战主要是：**由于`JavaScript`单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起。**

但是适当调整和分解大型运算任务为多个小任务，使得运算能够及时释放，不阻塞I/O调用的发起，这样既可同时享受到并行异步`I/O`的好处，又能充分利用`CPU`。

关于CPU密集型应用，Node的异步I/O已经解决了在单线程上CPU与I/O之间阻塞无法重叠利用的问题，**I/O阻塞造成的性能浪费远比`CPU`的影响小**。

对于长时间运行的计算，如果它的耗时超过普通阻塞I/O的耗时，那么应用场景就需要重新评估，因为这类计算比阻塞I/O还影响效率，甚至说就是一个纯计算的场景，根本没有I/O。此类应用场景或许应当采用多线程的方式进行计算。

Node虽然没有提供多线程用于计算支持，但是还是有以下两种方式来充分利用`CPU`

* Node可以通过编写`C/C++`扩展的方式更搞笑地利用`CPU`
* 如果单线程的`Node`不能满足需求，甚至用了`C/C++`扩展后还觉得不够，那么通过子进程的方式，将一部分`Node`进程当作常驻服务进程用于计算，然后利用进程间的消息来传递结果，将计算和`I/O`分离，这样还能充分利用`CPU`

### 与遗留系统和平相处

在Node中，语言层面即可天然并行的特性在这种场景中显得十分有效。对于已有的稳定系统，并非意味着我们要抛弃

### 分布式应用

阿里巴巴开发了中间层应用`NodeFox、ITier`，将数据库集群做了划分和映射，查询调用依旧是针对单张表进行`SQL`查询，中间层分解查询`SQL`，并行地去多台数据库中获取数据并合并。

## Node的使用者

* 前后端编程语言环境统一
* Node带来的高性能I/O用于实时应用
* 并行I/O使得使用者可以更高效地利用分布式环境
* 并行I/O，有效利用稳定接口提升Web渲染能力
* 云计算平台提供Node支持
* 游戏开发领域
* 工具类应用

# 二、模块机制

## `CommonJS`规范

`CommonJS`规范为JavaScript制定了一个美好的愿景 —— 希望JavaScript能够在任何地方运行。

Node能以一种比较成熟的姿态出现，离不开`CommonJS`规范的影响。

![image-20200325133951185](http://img.lijiawei0627.xyz/img/image-20200325133951185.png)

### `CommonJS`的模块规范

* 模块引用

  ```javascript
  var math = require('math')
  ```

* 模块定义

  将方法挂载在exports对象上作为属性即可定义导出的方式

* 模块标识

  模块标识其实就是传递给`require()`方法的参数,它必须是符合小驼峰命名的字符串,或者以....开头的相对路径,或者绝对路径。它可以没有文件名后缀`.js`.

`CommonJS`构建的这套模块导出和引入机制使得用户完全不必考虑变量污染。

## `Node`的模块实现

在Node中引入模块，需要经历如下3个步骤

* 路径分析
* 文件定位
* 编译执行

在Node中，模块分为两类：

* Node提供的模块——核心模块

  核心模块引入时,文件定位和编译执行这两个步骤可以省略掉,并且在路径分析中优先判断,所以它的加载速度是最快的。

* 用户编写的模块——文件模块

  文件模块则是在运行时动态加载,需要完整的路径分析、文件定位、编译执行过程,速度比核心模块慢。

### 优先从缓存加载

`Node`对引入过的模块都会进行缓存,以减少二次引入时的开销。不同的地方在于,浏览器仅仅缓存文件,而Node缓存的是编译和执行之后的对象。不论是核心模块还是文件模块, `require()`方法对相同模块的二次加载都一律采用缓存优先的方式,这是第一优先级的。不同之处在于核心模块的缓存检查先于文件模块的缓存检查。

### 路径分析和文件定位

