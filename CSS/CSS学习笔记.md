# 一、为网页添加样式
## 1、术语解释
```css
h1 {
      color: red;
      background-color: lightblue;
      text-align: center;
    }
```
`CSS`规则 = 选择器 + 声明块

#### 选择器
选择器：选中元素
* ID选择器：选中的是对应的id值的元素
* 元素选择器
* 类型选择器
#### 声明块
* 出现在大括号中
* 声明块中包含很多声明（属性），每一个声明（属性）表达某一方面的样式。
## 2、`CSS`代码书写位置
* 内部样式表
书写在style元素中

* 内联样式表（行间样式）【不推荐】
直接书写在元素的style属性中
* 外部样式表【推荐】
将样式书写到独立的`CSS`文件中。
**优点：**
1）、外部样式可以解决多页面样式重复的问题
2）、有利于浏览器缓存，从而提高页面响应速度
3）、有利于代码分离（`HTML和CSS`），更容易阅读和维护
---
# 二、`CSS`书写规范

## 空格规范

【强制】 **选择器 与 `{` 之间必须包含空格**

```
.select {}
```

【强制】**属性名与之后的 `：`之间不允许包含空格，`：`与属性值之间必须包含空格**

```css
font-size: 12px;
```

## 选择器规范

【强制】**当一个rule包含多个selector时，每个选择器声明必须独占一行**

```css
/* good */
.post,
.page,
.comment {
  line-height: 1.5;
}

/* bad */
.post, .page, .comment P{
  line-height: 1.5;
}
```

【建议】**选择器的嵌套层级应不大于3级，位置靠后的限定条件尽可能精确**

```css
/* good */
#username input {}
.comment .avatar li {}

/* bad */
.page .header .login #username input {}
```

## 属性规范

【强制】**属性定义必须另起一行**

```css
/* good */
.selector {
  margin: 0;
  padding: 0;
}

/* bad */
.selector {
  margin: 0; padding: 0;
}
```

【强制】**属性定义后必须以分号结尾**

# 三、常见样式声明

## 1、color
**元素内部的文字颜色**

**预设值：**定义好的单词

**十六进制表示法**：`#fff`、`#000`

**三原色，色值：**光学三原色（红、绿、蓝），每个颜色可以使用0-255之间的数字来表达，色值。

```css
rgb表示法：color: rgb(42, 80, 29);
hex（16进制）表示法：color: #428029;
（#红绿蓝）
```
## 2、background-color
**元素背景颜色**

## 3、font-size
**元素内部文字的尺寸大小**

* `px`：像素，绝对单位，简单的理解为**文字的高度**占多少个像素
* em：相对单位，相对于父元素的字体大小，如果各层父元素都没有设置字体大小，则使用基准字号。
>user agent，UA，用户代理（浏览器）
## 4、font-weight
**文字粗细程度，可以取值数字，也可以取值为预设值**

## 5、font-family
**文字类型**
* 必须用户计算机中存在的字体才会生效。
* 使用多个字体以匹配不同环境
```css
div {
      font-family: consoles,翩翩体-简,微软雅黑,Arial,sans-serif;
    }
//sans-serif，非衬线字体
```
## 6、font-style
**字体样式，通常用它设置斜体**
>i元素，默认样式，是倾斜字体；实际使用中，通常用它表示一个图标。
## 7、text-decoration
**文本修饰，给文本加线。**

>a元素
>del元素：错误内容
>s元素：过期的内容
## 8、text-indent
**首行文本缩进**

```css
//首行文本缩进两个汉字
text-indent: 2em
```
## 9、line-height
**每行文本的高度，该值越大，每行文本的距离越大**

* 设置行高为容器的高度，可以让单行文本垂直居中。
* 多行文字下避免使用`px`为单位给line-height设置大小，应该使用相对单位。
* 行高可以设置为纯数字【推荐】，表示相对于当前字体大小，也可以设置为em单位。
```css
line-height: 1.5;  （1.5*font-size）
line-height：2em；
```
## 10、width
**宽度**
## 11、height
**高度**
## 12、text-align
**元素内部文字的水平排列方式，默认靠左** 

## 13、letter-space
**文字间隙**

## 14、word-space

**单词间距**（针对于英文单词间距）

---
## 15、table

<table> 标签定义 HTML 表格。

简单的 HTML 表格由 table 元素以及一个或多个 tr、th 或 `td` 元素组成。

tr 元素定义表格行，th 元素定义表头，`td` 元素定义表格单元。

更复杂的 HTML 表格也可能包括 `caption、col、colgroup、thead、tfoot 以及 tbody` 元素。

**重要属性：**

* `cellpadding`：规定单元边缘与内容之间的空白
* `cellspacing`：规定单元格之间的空白

### 表格的细线边框

```css
border-collapse: collapse;  // 表示边框合并在一起
```

# 四、选择器

**帮助你精准的选中你想要的元素**
#### ID选择器
#### 元素选择器
#### 类选择器
#### 通配符选择器
```css
*（星号）可以选中所有元素
```
#### 属性选择器
```css
//选中所有具有href属性的元素
[href] {
      color: red;
    }
```
#### 伪类选择器

##### 链接伪类选择器

使用时，按照下面顺序书写

* link：超链接未访问状态
* visited：超链接访问过状态
* hover：鼠标悬停状态
```css
a:hover {
      color: red;
    }
```
* active：鼠标按下状态
（使用方式都与hover一样）

##### 结构伪类选择器

* :first-child：选取属于其父元素的首个子元素的指定选择器
* :last-child：选取属于其父元素的最后一个子元素的指定选择器
* :nth-child(n)：匹配属于其父元素的第N个子元素，不论元素的类型  （even 为偶数； odd为奇数；如果直接填个n的话，n从0开始，而元素排序是从1开始的，如：`2n+1`代表的是第一个元素）
* :nth-last-child(n)：选择器匹配属于其元素的第N个子元素的每个元素，不论元素的类型，从最后一个子元素开始计数。n可以是数字、关键词或公式。

##### 目标伪类选择器

  用来匹配文档中`url`中某个标志符的目标元素。

```css
#big-bam-boom:target {
  color: red;
}
```

```html
<h1 id="big-bam-boom">Kaplow!</h1>
<a href="#big-bam-boom">Mission Control, we're a little parched up here.</a>
```

上述代码的效果是当点击a链接，链接跳转到`h1`的时候，`h1`的文字会显示为红色

 #### 伪元素选择器
* before
* after
**例如：**
```css
<p>
    阅读<span>巴黎圣母院</span>
</p>
span::before {
      content: "《";
      color: red;
}
span::after {
  content: "》";
  color: red;
}
```
效果图：
![image.png](https://upload-images.jianshu.io/upload_images/16269351-07805e227c7b3381.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 选择器的组合
* 并且
```css
//p元素并且具有class属性值为red
p.red {
      
    }
```
* 后代选择器 —— 空格连接
```css
//div元素中所有具有class属性值为red的后代元素
div .red {

    }
```
* 子元素 —— >连接
```css
//直接包裹在div元素中具有class属性值为red的子元素
div >.red {

    }
```
* 相邻兄弟头元素 —— +连接
* 后面出现的所有兄弟元素 —— ~连接
#### 选择器的并列
**多个选择器，用多个逗号分隔**

```css
// 同时选择了P元素和span元素
p,span{
  
}
```

---
# 五、层叠
**声明冲突：**同一个样式，多次应用到同一个元素
**层叠：**解决声明冲突过程，浏览器自动处理（权重计算）

## 1、比较重要性
**重要性从高到低：**

>作者样式表：开发者书写的样式
* 作者样式表中！important样式
* 作者样式表中的普通样式
* 浏览器默认样式表中的样式
## 2、比较特殊性
**看选择器：**
* 总体规则：选择器选中的范围越窄，越特殊
* 具体规则：通过选择器，计算出一个4位数（xxxx）
1）、千位：如果是行间样式，记1，否则记0
2）、百位：等于选择器中所有id选择器的数量
3）、十位：等于选择器中所有类选择器、属性选择器、伪类选择器的数量
4）、个位：等于选择器中所有元素选择器、伪元素选择器的数量
## 3、比较源次序
**代码书写靠后的胜出**

## 4、应用
* ##### 重置样式表
**书写一些作者样式，覆盖浏览器的默认样式**

**常见的重置样式表：**`normalize.css、reset.css、meyer.css`

* ##### 爱恨法则（有关于源次序）
link > visited > hover > active

---
# 六、`CSS`继承性
**子元素会继承父元素的某些`CSS`属性**

恰当地使用继承可以简化代码，降低`CSS`样式的复杂性。子元素可以继承父元素的样式（text-、font-、line-这些元素开头的都可以继承，以及color属性也可以继承）

>  通常，跟文字内容有关的属性都能被继承

---
# 七、属性值的计算过程
**一个一个元素依次渲染,顺序按照页面文档的树形目录结构进行(深度优先渲染)**

* 渲染每个元素的前提条件:该元素的所有`css`属性必须有值

* 一个元素从所有属性都没有值,到所有属性都有值,这个过程叫做属性的计算过程

1.确定声明值(参考样式表中没有冲突的声明,作为`css`属性值)

2.层叠冲突(对样式表有冲突的声明使用层叠规则,确定`css`值)

3.使用继承(对仍然没有值的属性,若可以继承,则继承父元素的值)

4.使用默认值(对仍然没有值的属性,使用默认值)

---
# 八、盒模型
**box：盒子，每个元素在页面中都会生成一个矩形区域（盒模型）**

## 1、盒子类型：
* 行盒，`display`为`inline`的元素
* 块盒，`display`为`block`的元素
>**行盒在页面中不换行、块盒独占一行，display默认值为inline**

浏览器默认样式表设置的块盒：容器元素、`h1~h6`、p
常见的行盒：span、a、img、video、audio

## 2、盒子的组成部分
**无论是行盒还是块盒，都由下面几个部分组成，从内到外分别是：**
* 内容   content
**width、height，设置的是盒子内容的宽高**
* 填充（内边距）   padding
**盒子边框到盒子内容的距离**
* 边框   border
边框 = 边框样式 + 边框宽度 + 边框颜色
**边框 + 填充区 + 内容区 = 边框盒 border-box**
* 外边距   margin
边框到其它盒子的距离

**box-sizing属性值**

* content-box：这是由`CSS2.1`规定的宽度高度行为，宽度和高度分别应用到元素的内容框，在宽度和高度之外绘制元素的内边距和边框；

  ![](https://img-blog.csdn.net/20180619173347603?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2NzgwMzE3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

* border-box：为元素设定的宽度和高度决定了元素的边框盒，就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度;

  ![](https://img-blog.csdn.net/20180619174330697?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2NzgwMzE3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

* inherit：规定应从父元素继承box-sizing属性的值;

# 九、盒模型的应用
## 1、改变宽高范围
* 默认情况下，width和height设置的是内容盒宽高。
* 衡量设计稿尺寸的时候，往往使用的是边框盒，但设置width和height，则设置的是内容盒。
**解决方法：**
**1、精确计算**
**2、`CSS3：box-sizing`**
## 2、改变背景覆盖范围
**默认情况下，背景覆盖边框盒，可以通过background-clip进行修改**

## 3、溢出处理
 overflow，控制内容溢出边框盒后的处理方式
## 4、断词规则
**word-break，会影响文字在什么位置被截断换行。**

## 5、空白处理

  对于单行处理

```css
white-space: nowrap;
overflow: hidden;
text-overflow: ellipsis;
```
  对于多行处理

 只要调整 `-webkit-line-clamp` 的值就能实现在第n行[…]

```css
overflow: hidden;
text-overflow: ellipsis;
display: -webkit-box;
-webkit-line-clamp: 3;
-webkit-box-orient: vertical;
```

# 十、行盒的盒模型

**行盒：包含具体内容的元素**
strong、span、em、i、img（inline-block）、video、audio、a

## 1、显著特点
* 盒子沿着内容延伸
* **行盒中不能放块级元素，只能容纳文本或其他行内元素 （a元素除外）**
* 行盒不能设置宽高（宽高由内容决定），但是可以设置行高（line-height）
**调整行盒的宽高，应该使用字体大小、行高、字体类型进行间接调整**
* 内边距（填充区）、边框、外边距（**外边距在垂直方向会失效**）
**内边距水平方向有效，但是垂直方向不会实际占据空间。**（**我们尽量不要给行内元素指定上下的内外边距**）

> **行内元素在盒模型中的表现是这样的，元素的宽度与内容有关，高度仅仅与文字有关，水平方向的margin、padding等值占据位置和块元素中表现一样，但是垂直方向上的margin、padding不占据位置（也就是说占据位置仅仅是文字部分，设置margin、padding不会影响布局），但是垂直方向的margin、padding会有显示效果，可能导致覆盖前面的元素。**

## 2、行块盒
如：`img、input、td`等标签

`**display：inline-block**`

* 不独占一行
* 盒模型中所有尺寸都有效
* 默认宽度就是它本身内容的宽度。
## 3、空白折叠
**空白折叠，发生在行盒内部或行盒之间**

>行盒之间会存在一个间隙，该间隙大小为父元素的font-size大小，若要消掉间隙，可以给父元素设置font-size为0
## 4、可替换元素和非可替换元素
* 大部分元素，在页面上显示的结果，取决于元素内容，称为**非可替换元素**
* 少部分元素，在页面显示的结果，取决于元素属性，称为**可替换元素**
>可替换元素：img、video、audio。绝大部分可替换元素均为行盒。可替换元素类似于行块盒，可以设置宽高。
# 十一、常规流
**盒模型：规定单个盒子的规则**

**视觉格式化模型（布局规则）：页面中的多个盒子排列规则**

* 视觉格式化模型，大体上将页面中盒子的排列分为三种方式：
1、常规流
2、浮动
3、定位
## 1、常规流
**命名：常规流、文档流、普通文档流、常规文档流。**

**所有元素，默认情况下，都属于常规流布局**

* 总体规则：块盒独占一行，行盒水平依次排列
* 包含块：每个盒子都有它的包含块，包含块决定了盒子的排列区域。绝大部分情况下：盒子的包含块，为其父元素的内容盒。
## 2、块盒
##### 每个块盒的总宽度，必须刚好等于包含块的宽度
* 宽度、margin默认值是auto。
* auto：将剩余空间吸收掉，width吸收能力强于margin
>若宽度、边框、内边距
外边距计算后，仍然有剩余空间，该剩余空间被margin-right全部吸收。
* 在常规流中，若要块盒在包含块中居中，可以定宽，再设置margin为auto
##### 每个块盒在垂直方向上的auto值
* `height：auto，适应内容高度`
* `margin：auto，表示0`
##### 百分比取值
* padding、宽、margin可以取值为百分比
以上所有百分比都是相对于**包含块的宽度**百分比
* 包含块的高度取决于子元素的高度时，设置百分比无效。
* 包含块的高度不取决于子元素高度时，百分比相对于父元素高度。
## 3、上下外边距的合并
* 两个常规流块盒，上下外边距相邻，会进行合并。
* 两个外边距取最大值。
```css
//margin塌陷
<div class="one">
    <div class="two"></div>
</div>
.one{
    width: 1000px;
    height: 500px;
    margin-top: 50px;
    background-color: chartreuse;
}
.two {
    width: 100px;
    height: 100px;
    margin-top: 90px;
    background-color: cyan;
}
```
# 十二、浮动
* 文字环绕
* 横向排列
## 1、浮动的基本特点
##### 修改float属性值为：
* left：左浮动，元素靠上靠左
* right：右浮动，元素靠上靠右
* 默认值为none
##### 性质
* 当一个元素浮动后，元素必定为块盒（**更改display属性为inline-block**）
* 浮动元素的包含块，和常规流一样，为父元素的内容盒
## 2、盒子尺寸
* 宽度为auto时，适应内容宽度。
* 高度为auto时，与常规流一直，适应内容高度
* margin为auto时，为0
* 边框、内边距、百分比设置与常规流一样
## 3、盒子排列
* 左浮动的盒子靠上靠左排列
* 右浮动的盒子靠上靠右排列
* 浮动盒子在包含块中排列时，会避开常规流盒子
* 常规流块盒在排列时，无视浮动盒子
* 行盒在排列时，会避开浮动盒
>如果文字没有在行盒中，浏览器会自动生成一个行盒包裹文字，该行盒叫做匿名行盒
>
>* 外边距合并不会发生
>* 浮动盒子的顶边不得高于上一个浮动盒子的顶边
## 4、高度坍塌
```css
//class属性值为content的div此时高度为零
<div class="content">
    <div class="item"></div>
</div>
.content {
      background-color: cornsilk;
    }
.item {
  width: 100px;
  height: 100px;
  float: left;
  background-color: cyan;
}
```
**高度坍塌的根源：常规流盒子的自动高度，在计算时，不会考虑浮动盒子**
>解决方法：①、在最后一个浮动元素后面加一个常规流元素。比如div
②、创建BFC（创建BFC的元素，它的自动高度需要计算浮动元素）
③、给父元素content上加一个伪元素after，清除浮动。【推荐】
```css
.content::after {
      content: "";
      display: block;
      clear: both;
    }
```
## 5、清除浮动（让常规流盒子可以发现浮动盒子，设置在常规流盒子身上）
##### `CSS`属性：clear
* 默认值：none
* left：清除左浮动，该元素必须出现在前面所有左浮动盒子的下方
* right：清除右浮动，该元素必须出现在前面所有右浮动盒子的下方。
* both：清除左右浮动，该元素必须出现在前面所有浮动盒子的下方
# 十三、定位
**手动控制元素在包含块中的精准位置**
## 1、position属性
* 默认值：static，静态定位（不定位）
* relative：相对定位
* absolute：绝对定位 （**display属性值为inline-block**）
* fixed：固定定位  （**display属性值转变为inline-block**）
**一个元素只要position取值不是static，则认为该元素是一个定位元素，定位元素会脱离文档流（相对定位除外）**
## 2、脱离文档流：
* 文档流中的元素摆放时，会忽略脱离了文档流的元素
* 文档流中元素计算自动高度时，会忽略脱离了文档的元素
## 3、相对定位
* **不会导致元素脱离文档流，只是让元素在原来位置上进行偏移。**
* **盒子的偏移不会对其他盒子造成任何影响，因为它会保留原来的位置**
## 4、绝对定位
* 宽高为auto，适应内容
* 包含块变化：找祖先元素中第一个定位元素，该元素的填充盒为其包含块。若找不到，则它的包含块为整个网页（初始化包含块）
## 5、固定定位
* 其他情况和绝对定位完全一样。
* 包含块不同：固定为视口（浏览器的可视窗口）
## 6、定位下的居中
> 格式化宽度仅出现在绝对定位模型中

此处以垂直方向居中为例：（相对于最近的具有定位特性的祖先元素居中）

* 定高
* 将上下距离设置为相应的值（以`20px`为例）
```css
      position: fixed;
      height: 100px;
      left: 0;
      right: 0;
```
## 7、多个定位元素重叠时
##### 堆叠上下文
* 设置z-index，通常情况下，该值越大，越靠近用户。
* 只有定位元素设置z-index有效
* z-index可以是负数，如果是负数，则遇到常规流、浮动元素，则会被其覆盖。
## 8、补充
* 绝对定位、固定定位绝对是块盒。
* 绝对定位、固定定位元素一定不是浮动元素。
* 没有外边距合并
# 十四、@规则
**at-rule：**@规则、@语句、@`CSS`语句、`CSS`指令

## 1、import
@import 路径；
导入另外一个`CSS`文件

## 2、`charset`
@`charset "utf-8"`；
告诉浏览器该`CSS`文件，使用的字符编码集是`utf-8`，必须写在第一行

# 十五、块级格式化上下文（`BFC`）
**它是一块独立的渲染区域，它规定了该区域中，常规流块盒的布局**
## 1、`BFC`渲染区域
**这个区域由某个HTML元素创建，以下元素会在其内部创建`BFC`区域：**

* 根元素
* 浮动元素、绝对定位和固定定位元素
* overflow不等于visible的块盒

**不同的`BFC`区域，它们进行渲染时互不干扰**

创建`BFC`的元素，隔绝了它内部和外部的联系，内部的渲染不会影响到外部

**创建`BFC`的元素，它的自动高度需要计算浮动元素**

**创建`BFC`的元素，它的边框盒不会与浮动元素重叠**

**创建`BFC`的元素，不会和它的子元素进行外边距合并**

# 十六、扩展
## 1、行高的取值
只要设置行高就能使文字居中，尽量使用数字设置行高，而不是px或者em
## 2、body背景
##### 画布：一块区域
特点：
* 最小宽度为视口宽度
* 最小高度为视口高度
##### HTML元素的背景
覆盖画布
##### BODY元素的背景
* 如果HTML元素有背景，BODY元素正常（背景覆盖边框）
* 如果HTML元素没有背景，BODY元素的背景覆盖画布
## 关于画布的背景图
* 背景图的宽度百分比，是相对于视口
* 背景图高度百分比，是相对于HTML

**注：如果想要在窗体加载的时候让一个div的高度为屏幕的高度 那么只需要设置**

```css
html,body {
  width: 100%;  
  height: 100%;
}
// 或者
/* body {
  width: 100vw;
  height: 100vh;
} */
div {
  width: 100%;
  height: 100%;
}
```

